    [Video]: https://www.youtube.com/watch?v=gHISpAZiAm0&t=0s

-------------------------------------------------

# Linux

+ `nss` function (_functions with nss in it_) might result in a shared library being loaded
 - Qualys Security Advisory - Thhe Stack Clash (2017)
 - `return-into-libc`
   * redirect code execution into this library to load an attacker controlled library

+ `exec`: look for calls to this in a binary to do **privilige escalation**


-------------------------------------------------

# Debug Shellcode

[Video]: https://www.youtube.com/watch?v=re4teYmSoXA&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN&index=17

1. Use `\xcc` as a breakpoint
2. In `gdb` you can use `bt` to get backtrace
  + (gdb) bt


# See what shellcode look like with Hexdump

[Python2.7]:
└─$ python -c "print '\xcc\x48\x52'" | hexdump -C
00000000  cc 48 52 0a                                       |.HR.|
00000004

[Python3]:
└─$ python3 -c 'import sys; sys.stdout.buffer.write(b"\xcc\xcc\xcc")' | hexdump -C
00000000  cc cc cc                                          |...|
00000003

[Bash]:
└─$ echo -en "\xcc\x48\x52" | hexdump -C
00000000  cc 48 52                                          |.HR|
00000003


-------------------------------------------------

# Egg Hunter Code: Mat Miller's 32 bytes of egg hunter code
+ 17:50 in the `Video`
+ Code
```
\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05\x5a\x74\xef\xb8\x54\x30\x30\x57\x8b\xfa\xaf\x75\xea\xaf\x75\xe7\xff\xe7
```
+ Egghunter ca look for this `T00W` -> `\x54\x30\x30\x57`
 - It's `W00T` cause the hex is put in backwards cause of Litte Endian architecture


- - - - - - - - - - - - - - - -


[Intro to Egghunters]: https://www.youtube.com/watch?v=2c5HNS1mGbQ&list=PLCLxMnnAnGimvAQCZyKtfhmKA3-fTG9yU&index=19

   [NtDisplayString Egghunter]: takes a string as input and displays a textbox
    ```Windows7/XP/2003
    NTSYSAPI NTSTATUS NTAPI NtDisplayString(
    IN PUNICODE_STRING String
    );
    ```

* `0x43` is a syscall number for this function



-------------------------------------------------


# Opcodes allowed given alphanumeric restriction
+ ADD
+ SUB
+ AND
+ PUSH
+ POP
+ INC
+ JZ  - Jump if 0
+ JNZ - Jump if NOT 0
others?

```
;Zero Out
  AND EAX, 554E4D4A; for encoded version look at video 19:25
  AND EAX, 2A313235

;Get current location on stack
  PUSH ESP
  POP EAX

;Use arithmetic to get EAX to what we want
  SUB EAX 55554D66
  SUB EAX 55554B66
  SUB EAX 5555506A
; At the end of this operation, EAX should be pointing to the
;  address where our Egghunter code is
```


-------------------------------------------------


# Find current location on the stack
1. PUSH ESP             ;puts the value of the stack pointer onto the stack
2. POP EAX              ;pops off the top of the stack (value of ESP) and stores it in EAX
3. Do operations on EAX to calculate exact address value
4. PUSH EAX             ; this will push the address onto the stack
5. POP ESP or POP EIP   ; this will store the new address into the ESP


-------------------------------------------------


# BAD CHARACTERS

[13:50]: JE SHORT <some_address>
 - Op Code: `\xEB \x10`
 - this instruction may not be allowed

[14:28]: Allowed Bytes


-------------------------------------------------


[leave instruction]:
* mov EBP, ESP   ;  ebp = esp
* pop EBP


# Tricks
+ Zero out EAX so you can start carving out shellcode
```
32 BIT
    lea eax, [0]
    mov eax, 0FFFF0000h         //All constants form 0..0FFFFh << 16
    shr eax, 16                 //All constants form 16..31
    shl eax, 16                 //All constants form 16..31

  @movzx:
    movzx eax, byte ptr[@movzx + 6]   //Because the last byte of this instruction is 0
  @movzx:
    movzx ax, byte ptr[@movzx + 7]

# Works on any reg unless noted, usually of any size.  eax/ax/al as placeholders
and    eax, 0         ; three encodings: imm8, imm32, and eax-only imm32
andn   eax, eax,eax   ; BMI1 instruction set: dest = ~s1 & s2
imul   eax, any,0     ; eax = something * 0.  two encodings: imm8, imm32
lea    eax, [0]       ; absolute encoding (disp32 with no base or index).  Use [abs 0] in NASM if you used DEFAULT REL
lea    eax, [rel 0]   ; YASM supports this, but NASM doesn't: use a RIP-relative encoding to address a specific absolute address, making position-dependent code

mov    eax, 0         ; 5 bytes to encode (B8 imm32)
mov    rax, strict dword 0   ; 7 bytes: REX mov r/m64, sign-extended-imm32.    NASM optimizes mov rax,0 to the 5B version, but dword or strict dword stops it for some reason
mov    rax, strict qword 0   ; 10 bytes to encode (REX B8 imm64).  movabs mnemonic for AT&T.  normally assemblers choose smaller encodings if the operand fits, but strict qword forces the imm64.

sub    eax, eax         ; recognized as a zeroing idiom on some but maybe not all CPUs
xor    eax, eax         ; Preferred idiom: recognized on all CPUs


16 BIT
    lea  ax, [0]
  @movzx:
    movzx ax, byte ptr cs:[@movzx + 7]   //Check if 7 is right offset
```
