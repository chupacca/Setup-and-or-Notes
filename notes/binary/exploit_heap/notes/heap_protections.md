### Table of Contents
a. MITIGATIONS REFERENCE
b. MITIGATIONS
  1. Top Chunk
c. MITIGATION WORKAROUNDS
  1. `FREE()` CHUNK CHECK
  2. CHUNK SIZE CHECK
  3. SAFE LINK CHECK
  3. TOP CHUNK SIZE CHECK


---------------------------------------------------------------------------------------------------------------


# a. MITIGATIONS REFERENCE  = = = = = = = = = = = = = = = = = = = = = = = =

* Which `heap exploit exploitation` to which _version of libc_ look at pdf's _mitigation section_
 + `tcache` make `malloc` _easier to exploit_


---------------------------------------------------------------------------------------------------------------


# b. MITIGATIONS  = = = = = = = = = = = = = = = = = = = = = = = = = = = = =

### 1. TOP CHUNK
* _GLIBC 2.29_ introduced a top chunk size check that compares the size of a top chunk
     against a variable called `system_mem`, which


---------------------------------------------------------------------------------------------------------------


# c. MITIGATION WORKAROUNDS = = = = = = = = = = = = = = = = = = = = = = = =



### 1. `FREE()` CHUNK CHECK ================
                          **===== FREE CHUNK CHECK =====**
                          
* Check that the _top of the bin_ is **NOT** the _record_ we're going to add

  + Only the top of free list (in things like fastbins) is checked
   - so if I'm doing **double free on another chunk** that's not on top, then I get around this
   
        ```Not_Allowed
        free(a);
        free(a);
        ```
        ```Workaround
        free(a);
        free(b);
        free(a);
        ```
   
        ```Check_Source_Code
        if(SINGLE_THREAD_P)
        {
            if(__builtin_except (old == p, 0))
                malloc_printerr ("double free or corruption (fasttop)");
            p->fd = old;
            *fb = p;
            
        }
        else
            do
        ``` 


---------------------------------------------------------------------------------------------------------------


### 2. CHUNK SIZE CHECK ================
                             **===== CHUNK SIZE CHECK =====**
                             
* Checks if the _size of the chunk_ being _added to the list_ (like fastbin) is the _same sized list_
 + Example: Prevents a `0x90` sized _chunk_ from being added to the `0x30` sized _chunk_

    ------------------------------------------

  **Workaround 1 - SET Fake Chunk**

  - Set a _fake size chunk that matches_:
    `fake_chunk = p64(0) + p64(0x31)` <-- fake 0x31 chunk

    ------------------------------------------

  **Workaround 2 - FIND Fake Chunk**
  
  * In `pwndbg`'s function **find_fake_fast** to _find a nearby value_ with that can serve as a _fake chunk_
  * Using `heap/scripts/2_fastbin_dup/xpl_rce.py` as a template

    ------------------------------------------


---------------------------------------------------------------------------------------------------------------


### 3. SAFE LINK CHECK ================
                             **===== SAFE LINK CHECK =====**
                             
Checks:
  1. `fd->bk != p`
    + The `bk` pointer in the _next element_ of the list **does NOT point back to the victim**
  2. `bk->fd != p`
    + The `fd` pointer in the _previous element_ of the list **does NOT point back to the victim**

  3. `prev_size` fields **MUST MATCH**

+ `malloc` does not keep track of allocated chunks
 - Only maintain pointers to _heap's top chunks and free chunks_ in a respective arena
 - When a _chunk is allocated to a thread_ the thread is expected to keep a reference to the chunk
   until it returns it to `malloc`

+ **Initial heap pointer** may be in `.data` or `.bss` sections of binary
 - or storing the _chunk pointers_


---------------------------------------------------------------------------------------------------------------
