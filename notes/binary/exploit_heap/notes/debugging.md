### Table of Contents
1. CRASH 
2. ONE_GADGET CONSTRAINTS


* _Processes DON'T_ often cause `SIGABRT`, so if i get it, _something worked_


# DEBUGGING ---------------------------------------------------------------------------------------

### 1. CRASH
                           **=================**
                           **===== CRASH =====**
                           **=================**

1. When there's a _crash_, try looking at the function right before _main_ or _target function_
  + Alternatively, I just look through every one until one give me useful information
   ```
   ────────────[ BACKTRACE ]────────────
    ► f 0   0x7ffff7a5204a raise+202
      f 1   0x7ffff7a530f5 abort+3570
      f 2   0x7ffff7a93f07 __libc_message+599
      f 3   0x7ffff7a9b2aa
      f 4   0x7ffff7a9ccb4 _int_free+948
      f 5         0x400a22 main+603
      f 6   0x7ffff7a3e037 __libc_start_main+231
   ```

 + I can use _pwndbg_'s `frame` or `f` command
  - In this case `f 4`
  ```pwndbg> f 4
    #4  0x00007ffff7a9ccb4 in _int_free (av=0x7ffff7dd0b60 <main_arena>, p=0x603000, have_lock=0) at malloc.c:4266
    4266              malloc_printerr ("double free or corruption (fasttop)");    
  ```

 + Then I can call the `context code` or `context disassembly` to see what the last call was made



2. Inspect the the variables you've manipulated or injected

  + Get the value of a variable with `print` or `p`
   - `p &<variabe/function>` / `p <address> `
   - Example: `p &__malloc_hook` _<--This will print address that holds the function_
   
  + `dq <address>` / `dq &<variable/function>`
   - good to see the contents at an address
   - might want to do `dq &<functionName>-# #` _to see values before it_
    * `dq &_free_hook-16 18`
   
  + `db &<variable/function>` / `db <address>`
   - Good see the values in actual endianess
   
  + `dq &main_arena`
   - this will show the literal contents of fastbins (so probably addresses if it hasn't been manipulated)



3. If I see _there isn't a suitable size variable_
  + Use _pwndbg_'s `find_fake_fast &<variable>`
   - Use `dq`/`db`/`p` on the given address to see why it was recommended
```
pwndbg> dq 0x7ffff7dd0b2d
                                                     v---this is an acceptable size
                                                          for a heap chunk
00007ffff7dd0b2d     fff7dccee0000000 000000000000007f
``` 



4. WHEN DOING: `p &__malloc_hook` or something like this...
  + The value you get is the address value _like 0x7ffff7dd0b50_
  + `__malloc_hook` is a **pointer** so the _address value_ STORES A VALUE THAT **POINTS**
     to **ANOTHER ADDRESS**
  + So if the value at _0x7ffff7dd0b50_ is _0x00_ then it's **NULL POINTER**



---------------------------------------------------------------------------------------------------------------


### 2 ONE_GADGET CONSTRAINTS
               **==================================**
               **===== ONE_GADGET CONSTRAINTS =====**
               **==================================**


1. When checking constraints for one_gadget:
  + `pwndbg> regs` can show register values
  + `pwndbg> stack 14` can show stack values
  
  + This can be useful when you _write the rop gadget's address_ into a target address
    (such as `__malloc_hook`)
    

2. When have a separate line that targets an _intentionally bad address_ `like 0xdeadbeef` so you
   can debug the context of the program at that point in time
   
   ```example_from_fastbin_dup_challenge
   #malloc(0x28, b"Y"*19 + p64(libc.address + 0xe1fa1)) # this has been commented out for now
   malloc(0x28, b"Y"*19 + p64(0xdeadbeef)) # expected a crash when accessing address 0xdeadbeef
   ```
   



---------------------------------------------------------------------------------------------------------------
