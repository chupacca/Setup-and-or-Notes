### Table of Contents
1. Tools
2. Playbook
  + Guides
  + Tactics
  + PWNDBG
3. Useful `PWNDBG commands`

* Only show source code or context section: `pwndbg> set context-sections code`


--------------------------------------------------------------------------------------------------


# (1) Tool List -----------------------------------------------------------------------------------


**===== vim =====**
+ `:!./%` to run command

 - `:!./% GDB` to run current python file in gdb <---- **!!!!!**
  * must have gdbserver installed: `sudo apt install gdbserver`
  * _By default_ I'll get separte  `Shell No.#`
   * Press `Ctrl+C` in this shell (should be one with pwndbg)
  * Can click (alt + backtick) to toggle gdb and command prompt

 - `:!./% GDB NOASLR` - **debugging w/ ASLR is a PAIN!!!**


**===== ldd =====**
[Use]: ldd target_binary
+ Lists the shared libraries that a binary depends on


**===== pwndbg =====**
https://github.com/pwndbg/pwndbg
[Directory]: rev/gdb/gdb_heap.md
             **^GO HERE FOR SPECIFIC NOTES!!!!!!!!!!!!**
    
+ `Ctrl+c` can automatically pause program
 -  then run `continue` & `press Enter` to _resume_


**===== one_gadget =====**
https://github.com/david942j/one_gadget

 + Refernce `USING ONE_GADGET - ROP GADGETS` in `heap_rce_pointers.md`

```
When playing ctf pwn challenges we usually need the one-gadget RCE (remote code execution), which leads to call execve('/bin/sh', NULL, NULL).

This gem provides such gadgets finder, no need to use objdump or IDA-pro every time like a fool

To use this tool, type one_gadget /path/to/libc in command line and enjoy the magic
```


--------------------------------------------------------------------------------------------------
* _Processes DON'T_ often cause `SIGABRT`, so if i get it, _something worked_

# (2) Playbook ------------------------------------------------------------------------------------

### GUIDES

 1. Trying to find **heap exploits and `OTHER TACTICS`**?
   + Go to `heap_overflow.md`

 2. Trying to find **heap mitigations and bypasses**?
   + Go to `heap_mitigations.md`

 3. Trying to get **RCE (Remote Code Execution)** from _heap overflow_?
   + Go to `heap_rce_pointers.md`

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

### TACTICS
* `OTHER TACTICS` in `heap_overflow.md`

**Table of Contents**
1. Double Free
2. Heap bin holds an address to a piece of memory I control
3. When creating a Fake Chunk
4. Find a Fake Size Field

5. Code Execution

6. Mainpulating a Top Chunk's size field
7. When writing an address in exploit script 



**Contents**

 1. **Double free**: Look at `heap_overflow.md` & `heap_mitigations.md`
   + `OTHER TACTICS` in `heap_overflow.md`
   

 2. **Heap `bin`** holds an `address` to a **piece of memory I control**
   + Such a heap chunk I can write to
   + I can **CREATE A FAKE CHUNK**
   
 
 3. When **CREATING A FAKE CHUNK**
 
   + Make own `Fake Size Field`
    - If _fake chunk is in Actual Chunk_ ...
     * Ignore the _legitimate size field_ right before our `Fake Size Field`
     
    - keep account of the _size field check_ noted in `heap_mitigations.md`
     * This would apply to the `Fake Size Field`


   + If **NOT** planning on just _writing `userdata` NOW_ ...
    - ... have first `qword` be a `Fake Forward Pointer`


   + For the `Fake Forward Pointer` in the chunk ...
     
    - _subtract 16_ from the _target address_ for the `Fake Forward Pointer`
     * cause heap first looks over the first 16 bytes to look at size field
     * the size field may have flags
     * look at `General Notes` in `heap_notes.md`
     
    - _Target Address_ will need a **FAKE SIZE FIELD** nearby (section below)
    - Once I have a **FAKE SIZE FIELD** nearby my _Target Address_ ...
     * ... I can overwrite
     * Reference `Double Free - Fastbin Dup`'s  `Python_Pseudocode` in `heap_overflow.md`


 4. **FIND A FAKE SIZE FIELD**
   + Try `pwndbg> find_fake_fast [target]`
    - more in `Useful PWNDBG Commands` section below
    - `target` can point to `address` or `&function_name`


   + If I find a suitable size field nearby my target, I want to ...
    - Write data?
    - Overwrite a _function pointer_? **CODE EXECUTION** (section below)
    - Write shellcode? Look at **CODE EXECUTION** (section below)
    - Are you targeting a function poineter (like `__malloc_hook` or `__free_hook`)?
    - Look at `Target __malloc_hook or free_hook` in **CODE EXECUTION** (section below)
   


 5. **Code Execution**
    + RCE TIPS in `heap_rce_pointers.md`


    + ROP? (return oriented programming)
     * Refernce `USING ONE_GADGET - ROP GADGETS` in `heap_rce_pointers.md`


    + Shellcode I injected?


    + Target `__malloc_hook` or `__free_hook`
     - More detail in `Malloc Hook` and `Free HOOK` in `heap_rce_pointers.md`
     - Maybe reference `Double Free - Fastbin Dup`'s  `Python_Pseudocode` in `heap_overflow.md`
     
     - TL;DR
      * Next time `malloc`/`free` is called `__malloc_hook` / `__free_hook` executes
      
     - May need to **FIND A FAKE SIZE FIELD** (section above) around either addresses



 6. Mainpulating **top chunk's size field**
   + Look at _House of Force_ in `heap_overflow.md` for pointers



 7. When **WRITING AN ADDRESS IN EXPLOIT SCRIPT**
   + Try doing: 
        ```Python
            address_65_bits = p64(0) + p64(0x<target_address>)
            address_32_bits = p32(0) + p32(0x<target_address>)
        ```

- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

### PWNDBG

 1. **If `vis` won't work,** because _heap is corrupted..._
 
   + ... just try another way to _OBSERVE ARENA_: 
    - `dq &main_arena 20` 
 
   + Address of heap chunks should be in there
```void*a=malloc(1); 

pwndbg> dq &main_arena 20
00007ffff7dd0b60     0000000000000000 0000000000000000
00007ffff7dd0b70     0000000000000000 0000000000000000
               [...]           v----top_chunk address
00007ffff7dd0bc0     0000000000602060 0000000000000000
               [...]
```
```free(a); 

pwndbg> dq &main_arena 20
00007ffff7dd0b60     0000000000000000 0000000000000000
                               v----1st fastbin address
00007ffff7dd0b70     0000000000602000 0000000000000000
               [...]           v----top_chunk address
00007ffff7dd0bc0     0000000000602060 0000000000000000
               [...]
```


--------------------------------------------------------------------------------------------------


# (3) Useful PWNDBG Commands ----------------------------------------------------------------------

**Minimize Context After Every Step** **==========================**
* Only show source code or context section:
  `pwndbg> set context-sections code`

    
**vmmap** **======================================================**
+ Use `pwndbg`'s `vmmap` to see if _heap_ has been _allocated_

+ Takes an _argument_ to **filter results**
 - Example: `vmmap libc`
 

**print value** **================================================**
+ In `pwndbg`: `p <variable>`
 - Example: `p a` <--- variable name is a
 - Exanoke: `p __malloc_hook` <-- print value of a function pointer
 
 
**ptype** **======================================================**
+ Print a structure or print the type it is
+ Use: `ptype <variable/address>`
Example:
```
pwndbg> ptype user
type = struct user {
    char username[16];
    char target[16];
}
```
+ can also use `dq &<variable>`

 
**vis** **=======================================================**
+ Use `pwndbg`'s `vis_heap_chunks` or `vis` to see _heap chunks_

+ Usually the first link will have a **size**
 - Each chunk has a `size field`
```                                                     v--size_here
0x602000        0x0000000000000000      0x0000000000000021      ........!.......
  [...]
0x602060        0x0000000000000000      0x0000000000000021      ........!.......
  [...]
0x602080        0x0000000000000000      0x0000000000000031      ........1....... 
  [...]
0x602060        0x0000000000000000      0x0000000000020fa1      ................    <-- Top chunk
```

+ After the _size_, you should see the **userdata**
```                  userdata_is_YYYY_or_595959
0x603000        0x0000000000000000      0x0000000000000021      ........!.......
0x603010        0x0000000a59595959      0x0000000000000000      YYYY............
0x603020        0x0000000000000000      0x0000000000020fe1      ................    <-- Top chunk
```


**top_chunk** **======================================================**
+ See info related to the _top chunk_
```Example
pwndbg> top_chunk
Top chunk
Addr: 0x602000
Size: 0x1019       ; it's really big cause i overwrote it
```


**dq** **=========================================================**
+ Dumps _quadwords_
+ PREVIOUS `dq` call:  `!dq`

+ Use with _variable names_:
 - `dq <variable-name>`
 -`dq &<variable-name>`
 
+ _Address_ use:
 - `dq 0x<address>`

+ Can do _math operations_ in argument:
 - `dq target-16`

+ Gdb does _pointer math_ depending what you pass it:
 - `dq &__malloc_hook-2`


**db** **=========================================================**
+ Dumps _bytes_

+ example `db &__malloc_hook-4`
 - pwndbg usually shows bytes in reverse order, but keep in mind things are in little endian
  * this means dq is good for seeing things as they are in memory
  

**xinfo** **======================================================**
+ Get information about target

+ Confirm _which section_ it resides in (_like the .data section_)

+ Use: `xinfo <variable/address>`


**fastbins** **======================================================**
+ Gets the `fastbins` with size between _0x20~0x80_
+ Null (_0x0_) means the bin is empty

+ Note that if I want something in the _0x70_ `fastbin`
 - I have to `malloc` _0x68_ bytes because _8_ bytes are reserved for the chunk size
  * It's hex so: _0x68 0x69 0x6a 0x6b 0x6c 0x6d 0x6e 0x6f_


**arena/arenas** **===================================================**
+ print things related to arenat
+ can also do `dq &main_arena #` like `dq &main_arena 20`


**find_fake_fast <target>** **============================-**
+ prints locations of fake chunks that overlap the target address
+ `target` can point to `address` or `&function_name`

--------------------------------------------------------------------------------------------------
