# Table of Contents
1.  Beating ASLR
2.  USING ONE_GADGET - ROP GADGETS
3.  execve
4.  System
5.  TARGET: Array of Function Pointers
6.  FULLRELRO
7.  GLIBC Leak
8.  Targeting Heap for RCE
9.  Malloc Hooks
10. Free Hooks


---------------------------------------------------------------------------------------------------------------


# RCE Points --------------------------------------------------------------------------------------

### (1) BEATING ASLR

+ In _x86_ linux platforms, libraries are alwasy mapped to addresses that start with:
  `0x00007f ...`


---------------------------------------------------------------------------------------------------------------


### (2) USING ONE_GADGET - ROP GADGETS

  **Trying to Use It**
  
+ I can use the `one_gadget` command line tool to find something:
 - Teamplate: `one_gadget $(ldd [target_binary] | grep [target_library].so|cut -d' ' -f3)`
 - Example: `one_gadget $(ldd fastbin_dup | grep libc.so|cut -d' ' -f3)`
 
 - Pay attention to the **contraints** for each _gadget_
  * To prevent processing _broken arguments_


  * If targeting a _libc function_ like `execve`...
     Note that the **C11 standard** _IGNORES the first entry of any argv array in MOST CASES_
      ^ so if the following qword is _0x00_ (assuming we're working with a `==NULL` constraint)
        that should be _good enough_
        _see 11:23 of Code execution via the Fastbin Dup in first Heap Exploit video on Udemy_


  * Set a **breakpoint** at the start of the last part _before this gadget is processed_
    (an **example** is `bp *__malloc_hook`)
    
    
  * **Advantage** when getting to control **2 or more arguments** passed to a `one_gadget`
    + Modern shell will reset your _effective UID_ if it doesn't match you _actual UID_
     - Not much we can do aoubt this
     
    1. We can pass the `-p` option which _disables_ the above behavior
       ```fastbin_dup_challenge_(on_video)
       malloc(0x58, b"-p\0")
       malloc(0x58, b"-s\0")
       ```


  **Scripting / Alternative to remembering the offset**
  
+ Use `one_gadget`'s `--script`
+ `--script` flag
 - Run exploit script with every gadget it finds.


---------------------------------------------------------------------------------------------------------------


### (3) execve
 + Check the registers before the `one_gadget` executes this
  - the registers serve as the argument to `execve`
  
  - use the `-s` flag to take in arguments as user input as _stdin_ so you can ignore succeeding argument
    (use the solution to fastbin_dup_challlenge as a reference)
    ```fastbin_dup_challenge
    malloc(0x58, b"-s\0")
    malloc(0x58, b"G"*8)
    
    malloc(0x58, p64(0)*6 + p64(libc.sym.__malloc_hook - 0x24))
    
    malloc(0x28, p8(0)*0x14 + p64(libc.address + 0xe1fa1)) # [rsp+0x50] == NULL
    malloc(0x18, b"")
    ```
  

---------------------------------------------------------------------------------------------------------------


### (4) SYSTEM
+ The string `/bin/sh` already exists in libc because the `execve` command uses it and passes
  it to `system`
```python
libc = ELF(elf.runpath + b"/libc.so.6")
cmd =  next(libc.search(b""/bin/sh"))
```


---------------------------------------------------------------------------------------------------------------


### (5) TARGET: ARRAY OF FUNCTION POINTERS

**PLT**
 + Writeable **array of function pointers**
  - every _funtion_ call is in _external library_ (like libc)
  - Does lazy linking
   * address is _only resolved when it's first called_

 + `FULL RELRO` would make overwriting these **NOT POSSIBLE**
  - (Look at `#6 FULL RELRO` below)


**fini_array**
 + `fini_array` is another **array of function pointers**
  - EACH funtion in `fini_array` is called _as fucntion exits_
  - If program exits this will be triggered
  
 + `FULL RELRO` would make overwriting these **NOT POSSIBLE**
  - (Look at `#6 FULL RELRO` below)
  
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


`GLIBC's PLT` will be _writeable_ through _program lifetime_
 + Difficult to trigger calss to the functions within it

  **GLIBC's PLT: __exit_funcs**
   + Another of `libc's` procedure linkage tables
   + Behaves _similarly_ to `fini_array`
  
  
  **GLIBC's PLT: tls_dtor_list**
   + Another of `libc's` procedure linkage tables
   + Behaves _similarly_ to `fini_array`




---------------------------------------------------------------------------------------------------------------


### (6) Full RELRO
 + `PLT` and `fini_array` would be marked as **read-only** after initialization


---------------------------------------------------------------------------------------------------------------


### (7) GLIBC LEAK

+ LibC also has PLT alongside 2 other structures:
 1. `__exit_funcs`
 2. `tls_dtor_list`
 - Both of these are _protected by Pointer Guard_
  * whihc makes reliably tampering them difficult
 
+ While `GLIBC's PLT` _is writeable throughout program lifetime_ it is...
  _difficult to call to the functions within it_
 - Though `malloc hooks` can be useful



---------------------------------------------------------------------------------------------------------------


### (8) Targeting Heap for RCE

+ Might not need heap link under certain conditions (like if size of top chunk is too large)
 - **Distance** from the _top of the chunk_ & and the _target_ is **relative**

+ Only useful if `USEFUL INFO` like _function pointers_ or _sensitive_ data is on the heap

+ Coud target `Malloc Hook functions` (look at `#9 MALLOC HOOKS` below)
+ Coud target `Free Hook functions`   (look at `#10 FREE HOOKS` below)

---------------------------------------------------------------------------------------------------------------


### (9) MALLOC HOOKS

 * May need **FAKE SIZE FIELD**: look at `FIND FAKE SIZE FIELD` in `1_cmds_tools_playbook.md`
 
 + Each of malloc's core functions (like `malloc()` and `free()`) has an associated hook
  - Format `libc.sym.__<libcFunction>_hook`


 + These `hooks`  are a _writeable function pointer in GLIBC's .data section_
  - normally these can be used by developers to do own memory allocators or collect malloc stats
  
```See->pwntools_solution-shell.py
distance = (libc.sym.__malloc_hook - offset) - (heap_address + offset)

malloc(distance, "/bin/sh\0") # custom malloc in python (see scripts for specifics)
                               # REMEMBER TO NULL TERMINATE STRINGS!!!

malloc(24, p64(libc.sym.system)) # makes __malloc_hook point to system
                                 # arguments originally passed to malloc will be passed to system
```


---------------------------------------------------------------------------------------------------------------


### (10) FREE HOOKS
 * May need **FAKE SIZE FIELD**: look at `FIND FAKE SIZE FIELD` in `1_cmds_tools_playbook.md`
 
 + `libc.sym.__free_hook` is useful because its' first and only pointer will always point to _chunk userdata_
 
 
---------------------------------------------------------------------------------------------------------------






